<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pashie</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#1a7b7b" />
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />

  <!-- React & Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- ZXing (fallback scanner) -->
  <script src="https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/umd/index.min.js"></script>

  <!-- JsBarcode (generate barcode from digits) -->
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

  <!-- Tesseract (OCR fallback to read digits) -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    :root {
      --primary: #1a7b7b;
      --bg: #f5f7fb;
      --text: #1a202c;
      --muted: #718096;
      --danger: #c53030;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    #root {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
      background: #fff;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 30px rgba(0,0,0,0.08);
      position: relative;
    }

    .app { display: flex; flex-direction: column; min-height: 100vh; }
    .content { flex: 1; overflow-y: auto; padding: 16px; }

    .header {
      padding: 14px 18px;
      border-bottom: 1px solid #e2e8f0;
      position: sticky; top: 0; z-index: 5;
      background: #ffffffcc;
      backdrop-filter: blur(10px);
      padding-top: calc(14px + env(safe-area-inset-top));
    }
    .header-inner { display: flex; align-items: center; gap: 12px; }
    .header-logo-box {
      width: 40px; height: 40px;
      border-radius: 14px;
      background: #e6fffa;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(26,123,123,0.25);
      flex-shrink: 0;
    }
    .header-logo-img { width: 100%; height: 100%; object-fit: cover; }
    .header-title { font-size: 19px; font-weight: 800; margin: 0; letter-spacing: 0.08em; text-transform: uppercase; }
    .header-subtitle { font-size: 11px; color: var(--muted); margin: 2px 0 0; }

    .bottom-nav {
      display: flex;
      border-top: 1px solid #e2e8f0;
      background: #fff;
      padding-top: 6px;
      padding-bottom: calc(8px + env(safe-area-inset-bottom));
      position: sticky; bottom: 0; z-index: 6;
    }
    .nav-button {
      flex: 1;
      padding: 10px 4px;
      border: none;
      background: none;
      font-size: 13px;
      color: var(--muted);
      display: flex; flex-direction: column; align-items: center; gap: 4px;
      cursor: pointer;
    }
    .nav-button.nav-active { color: var(--primary); font-weight: 700; }
    .nav-icon { font-size: 20px; }

    .section-title { font-size: 16px; font-weight: 700; margin: 0 0 4px; }
    .section-text { font-size: 12px; color: var(--muted); margin: 0 0 12px; }

    .field-label { font-size: 12px; font-weight: 700; margin-bottom: 4px; }
    .input {
      width: 100%;
      padding: 10px 12px;
      font-size: 15px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      outline: none;
    }
    .input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 1px rgba(26,123,123,0.25);
    }
    .helper { font-size: 11px; color: var(--muted); margin-top: 5px; }

    .button-primary {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .button-secondary {
      background: #edf2f7;
      color: #2d3748;
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .button-danger {
      background: #fff5f5;
      color: var(--danger);
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .button-row { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }

    .scan-box {
      border-radius: 12px;
      border: 1px dashed #cbd5e0;
      padding: 12px;
      background: #f7fafc;
      margin-bottom: 16px;
    }
    .scan-view-container {
      position: relative;
      margin-top: 8px;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      border: 1px solid #111;
    }
    video.scan-video {
      width: 100%;
      height: 280px;
      object-fit: cover;
      display: block;
      background: #000;
    }
    .scan-guides {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none;
    }
    .scan-guides-box {
      width: 82%;
      height: 44%;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.95);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.45);
    }
    .scan-guides-text {
      position: absolute;
      bottom: 8px; left: 0; right: 0;
      text-align: center;
      font-size: 11px;
      color: #f7fafc;
      text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }
    .scan-status {
      margin-top: 8px;
      font-size: 12px;
      color: #2d3748;
      display:flex; align-items:center; justify-content:space-between; gap:8px;
    }
    .pill {
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 4px 10px;
      border-radius: 999px;
      font-size: 11px;
      background: #e2e8f0;
      color: #2d3748;
    }

    .error-box {
      margin-top: 8px;
      padding: 10px;
      border-radius: 10px;
      background: #fff5f5;
      color: var(--danger);
      font-size: 12px;
      white-space: pre-wrap;
    }
    .success-box {
      margin-bottom: 14px;
      padding: 10px;
      border-radius: 10px;
      background: #e6fffa;
      color: #22543d;
      font-size: 13px;
    }

    /* tiles */
    .card-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .card-item {
      border-radius: 14px;
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      cursor: pointer;
      display: flex; flex-direction: column;
      align-items: stretch; justify-content: space-between;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      position: relative;
    }
    .card-image {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    .card-overlay {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      padding: 10px;
      background: linear-gradient(to top, rgba(0,0,0,0.65), rgba(0,0,0,0));
      color: #fff;
    }
    .card-title { font-size: 16px; font-weight: 800; line-height: 1.1; margin-bottom: 4px; }
    .card-sub { font-size: 12px; opacity: 0.9; }
    .card-plain-center {
      padding: 12px;
      height: 100%;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      text-align: center;
      gap: 6px;
    }

    .empty-state { text-align: center; padding: 40px 16px; color: var(--muted); font-size: 13px; }
    .empty-icon { font-size: 38px; margin-bottom: 8px; }

    /* overlay */
    .fullscreen-overlay {
      position: fixed; inset: 0;
      background: rgba(15,23,42,0.95);
      display: flex; align-items: center; justify-content: center;
      z-index: 50;
    }
    .fullscreen-inner {
      max-width: 420px;
      width: 100%;
      padding: 22px 16px;
      text-align: center;
      color: #f7fafc;
    }
    .fullscreen-card {
      background: #fff;
      border-radius: 18px;
      padding: 16px;
      color: #1a202c;
      box-shadow: 0 14px 30px rgba(0,0,0,0.5);
    }
    .fullscreen-close-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 12px;
      color: #e2e8f0;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.4);
      font-size: 11px;
    }

    .barcode-svg { width: 100%; height: 140px; }
    .barcode-value {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 16px;
      letter-spacing: 0.18em;
      margin-top: 10px;
    }

    /* Cropper */
    .crop-stage {
      position: relative;
      width: 100%;
      height: 360px;
      background: #0b1220;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      touch-action: none;
    }
    .crop-stage img {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      transform-origin: center center;
      user-select: none;
      -webkit-user-drag: none;
    }
    .crop-mask {
      position: absolute; inset: 0;
      pointer-events: none;
      display: flex; align-items: center; justify-content: center;
    }
    .crop-hole {
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.95);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.55);
    }
    .crop-controls {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      margin-top:10px;
      flex-wrap:wrap;
    }

    .toggle-row {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      margin-top: 10px;
    }
    .toggle-row label { font-size: 13px; font-weight: 700; }
    .toggle-row input { transform: scale(1.1); }

    /* Splash */
    .splash-overlay {
      position: absolute; inset: 0;
      background: radial-gradient(circle at top, #ff6b6b 0, #1a7b7b 45%, #0b2545 100%);
      display: flex; align-items: center; justify-content: center;
      z-index: 100;
      color: #f7fafc;
    }
    .splash-inner { text-align: center; padding: 24px; }
    .splash-logo-circle {
      width: 96px; height: 96px; border-radius: 999px;
      background: rgba(15,23,42,0.3);
      border: 2px solid rgba(255,255,255,0.8);
      display: flex; align-items: center; justify-content: center;
      margin: 0 auto 16px;
      overflow: hidden;
      box-shadow: 0 18px 40px rgba(0,0,0,0.5);
    }
    .splash-logo-circle img { width: 100%; height: 100%; object-fit: cover; }
    .splash-name {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      text-indent: 0.24em;
      margin-bottom: 6px;
    }
    .splash-subtitle {
      font-size: 12px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0.9;
      margin-bottom: 10px;
    }
    .splash-tagline { font-size: 11px; opacity: 0.85; }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
  const { useEffect, useMemo, useRef, useState } = React;

  /***********************
   * JSON Storage
   ***********************/
  function loadStorage(key, fallback) {
    try { const val = localStorage.getItem(key); return val ? JSON.parse(val) : fallback; }
    catch { return fallback; }
  }
  function saveStorage(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch {} }

  /***********************
   * IndexedDB for images
   ***********************/
  const DB_NAME = "pashie_db";
  const DB_VERSION = 1;
  const STORE_IMAGES = "images";

  function idbOpen() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_IMAGES)) {
          db.createObjectStore(STORE_IMAGES, { keyPath: "id" });
        }
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbPutImage(blob) {
    const db = await idbOpen();
    const id = "img_" + Date.now() + "_" + Math.random().toString(16).slice(2);
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_IMAGES, "readwrite");
      tx.objectStore(STORE_IMAGES).put({ id, blob });
      tx.oncomplete = () => resolve(id);
      tx.onerror = () => reject(tx.error);
    });
  }

  async function idbGetImage(id) {
    if (!id) return null;
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_IMAGES, "readonly");
      const req = tx.objectStore(STORE_IMAGES).get(id);
      req.onsuccess = () => resolve(req.result ? req.result.blob : null);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbDeleteImage(id) {
    if (!id) return;
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_IMAGES, "readwrite");
      tx.objectStore(STORE_IMAGES).delete(id);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
  function blobToObjectUrl(blob) { return blob ? URL.createObjectURL(blob) : null; }

  /***********************
   * Scan engine (multi-layer)
   * 1) BarcodeDetector (if available)
   * 2) ZXing (fallback)
   * 3) OCR digits from frame (fallback)
   ***********************/
  function isBarcodeDetectorAvailable() {
    return typeof window.BarcodeDetector === "function";
  }

  function normalizeDigitsCandidate(text) {
    if (!text) return "";
    // keep digits only, allow spaces removed
    const digits = String(text).replace(/[^\d]/g, "");
    return digits;
  }

  function pickBestDigitsFromText(text) {
    if (!text) return "";
    // Find longest digit run of length >= 6
    const runs = String(text).match(/\d{6,20}/g);
    if (!runs || runs.length === 0) return "";
    runs.sort((a,b) => b.length - a.length);
    return runs[0];
  }

  async function ocrDigitsFromCanvas(canvas) {
    if (!window.Tesseract) throw new Error("OCR library ontbreekt (Tesseract).");
    const worker = await window.Tesseract.createWorker("eng");
    try {
      await worker.setParameters({
        tessedit_char_whitelist: "0123456789",
        classify_bln_numeric_mode: 1,
      });
      const { data } = await worker.recognize(canvas);
      const best = pickBestDigitsFromText(data?.text || "");
      return best;
    } finally {
      try { await worker.terminate(); } catch {}
    }
  }

  /***********************
   * App
   ***********************/
  function App() {
    const [activeTab, setActiveTab] = useState("cards");
    const [cards, setCards] = useState(() => loadStorage("pashie_cards", []));
    const [sortBy, setSortBy] = useState(() => loadStorage("pashie_sort", "alphabetical"));
    const [selectedCard, setSelectedCard] = useState(null);
    const [showSplash, setShowSplash] = useState(true);

    useEffect(() => saveStorage("pashie_cards", cards), [cards]);
    useEffect(() => saveStorage("pashie_sort", sortBy), [sortBy]);

    useEffect(() => {
      const t = setTimeout(() => setShowSplash(false), 2600);
      return () => clearTimeout(t);
    }, []);

    function addCard(card) { setCards(prev => [...prev, card]); }

    async function updateCard(id, updates) {
      // If replacing images, delete old blobs
      const prev = cards.find(c => c.id === id);
      if (prev) {
        if (updates.cardImageId && prev.cardImageId && updates.cardImageId !== prev.cardImageId) {
          await idbDeleteImage(prev.cardImageId);
        }
        if (updates.barcodeImageId && prev.barcodeImageId && updates.barcodeImageId !== prev.barcodeImageId) {
          await idbDeleteImage(prev.barcodeImageId);
        }
      }
      setCards(prevCards => prevCards.map(c => (c.id === id ? { ...c, ...updates } : c)));
    }

    function markUsed(id) {
      setCards(prev => prev.map(c =>
        c.id === id ? { ...c, lastUsed: new Date().toISOString(), usageCount: (c.usageCount || 0) + 1 } : c
      ));
    }

    async function deleteCard(id) {
      const c = cards.find(x => x.id === id);
      if (c?.cardImageId) await idbDeleteImage(c.cardImageId);
      if (c?.barcodeImageId) await idbDeleteImage(c.barcodeImageId);
      setCards(prev => prev.filter(x => x.id !== id));
    }

    function sortedCards() {
      const arr = [...cards];
      if (sortBy === "alphabetical") return arr.sort((a,b) => (a.storeName || "").localeCompare(b.storeName || ""));
      if (sortBy === "date") return arr.sort((a,b) => new Date(b.dateAdded) - new Date(a.dateAdded));
      if (sortBy === "mostUsed") return arr.sort((a,b) => (b.usageCount||0) - (a.usageCount||0));
      return arr;
    }

    return (
      <div className="app">
        {showSplash && (
          <div className="splash-overlay">
            <div className="splash-inner">
              <div className="splash-logo-circle">
                <img src="icons/icon-192.png" alt="Pashie" />
              </div>
              <div className="splash-name">Pashie</div>
              <div className="splash-subtitle">Membership cards in your pocket</div>
              <div className="splash-tagline">üí≥ E√©n plek voor al je pasjes ‚Äì lokaal, simpel, snel.</div>
            </div>
          </div>
        )}

        <header className="header">
          <div className="header-inner">
            <div className="header-logo-box">
              <img className="header-logo-img" src="icons/icon-192.png" alt="Pashie" />
            </div>
            <div style={{display:"flex", flexDirection:"column"}}>
              <div className="header-title">Pashie</div>
              <div className="header-subtitle">Je klantenkaarten altijd bij de hand ‚Äî zonder account.</div>
            </div>
          </div>
        </header>

        <main className="content">
          {activeTab === "scan" && (
            <ScanTab
              onSaved={(card) => { addCard(card); setActiveTab("cards"); }}
            />
          )}
          {activeTab === "cards" && (
            <CardsTab
              cards={sortedCards()}
              sortBy={sortBy}
              onOpenCard={(card) => { setSelectedCard(card); markUsed(card.id); }}
            />
          )}
          {activeTab === "settings" && (
            <SettingsTab
              cards={cards}
              sortBy={sortBy}
              setSortBy={setSortBy}
              onDeleteCard={deleteCard}
              onEditCard={updateCard}
            />
          )}
          {activeTab === "help" && <HelpTab />}
        </main>

        <nav className="bottom-nav">
          <button className={"nav-button " + (activeTab === "scan" ? "nav-active" : "")} onClick={() => setActiveTab("scan")}>
            <div className="nav-icon">üì∑</div><span>Scan</span>
          </button>
          <button className={"nav-button " + (activeTab === "cards" ? "nav-active" : "")} onClick={() => setActiveTab("cards")}>
            <div className="nav-icon">üí≥</div><span>Pasjes</span>
          </button>
          <button className={"nav-button " + (activeTab === "settings" ? "nav-active" : "")} onClick={() => setActiveTab("settings")}>
            <div className="nav-icon">‚öôÔ∏è</div><span>Instellingen</span>
          </button>
          <button className={"nav-button " + (activeTab === "help" ? "nav-active" : "")} onClick={() => setActiveTab("help")}>
            <div className="nav-icon">‚ùì</div><span>Help</span>
          </button>
        </nav>

        {selectedCard && (
          <BarcodeOverlay
            card={selectedCard}
            onClose={() => setSelectedCard(null)}
          />
        )}
      </div>
    );
  }

  /***********************
   * ScanTab (multi-layer scan + timeout -> details)
   ***********************/
  function ScanTab({ onSaved }) {
    const SCAN_TIMEOUT_MS = 7000; // langer (user vroeg 2x), pas aan indien nodig
    const DETECT_FPS = 8;         // barcode detector loop
    const OCR_ON_TIMEOUT = true;  // probeer digits te lezen als scan faalt

    const [step, setStep] = useState("scan"); // "scan" | "details"
    const [scanning, setScanning] = useState(false);
    const [error, setError] = useState(null);
    const [status, setStatus] = useState("");

    const [storeName, setStoreName] = useState("");
    const [barcodeValue, setBarcodeValue] = useState("");
    const [barcodeFormat, setBarcodeFormat] = useState("");

    const [cardImageId, setCardImageId] = useState(null);
    const [barcodeImageId, setBarcodeImageId] = useState(null);

    const [showTextOnTile, setShowTextOnTile] = useState(true);
    const [cropRequest, setCropRequest] = useState(null); // {file, aspect, purpose, title}

    const videoRef = useRef(null);
    const streamRef = useRef(null);
    const scanTimerRef = useRef(null);

    // loops
    const rafRef = useRef(null);
    const lastDetectRef = useRef(0);

    // ZXing
    const zxingReaderRef = useRef(null);

    // Canvas for frame grabbing
    const frameCanvasRef = useRef(null);

    useEffect(() => {
      return () => { stopScan(); };
    }, []);

    async function stopScan() {
      if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
      scanTimerRef.current = null;
      if (rafRef.current) cancelAnimationFrame(rafRef.current);
      rafRef.current = null;

      // stop ZXing
      try { if (zxingReaderRef.current) zxingReaderRef.current.reset(); } catch {}

      // stop stream
      if (streamRef.current) {
        try { streamRef.current.getTracks().forEach(t => t.stop()); } catch {}
        streamRef.current = null;
      }
      setScanning(false);
      setStatus("");
    }

    async function ensureCamera() {
      const constraints = { video: { facingMode: "environment" }, audio: false };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      streamRef.current = stream;

      if (videoRef.current) {
        videoRef.current.srcObject = stream;
        // iOS likes this
        videoRef.current.setAttribute("playsinline", "true");
        videoRef.current.muted = true;
        await videoRef.current.play();
      }
      return stream;
    }

    function openDetails(manual = false) {
      setStep("details");
      if (manual && !barcodeFormat) setBarcodeFormat("MANUAL_ENTRY");
    }

    async function startScan() {
      setError(null);
      setBarcodeValue("");
      setBarcodeFormat("");
      setStatus("");
      setStep("scan");

      try {
        if (!navigator.mediaDevices?.getUserMedia) {
          setError("Camera niet beschikbaar in deze browser.");
          return;
        }

        await ensureCamera();
        setScanning(true);

        // timeout -> try OCR -> details
        if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
        scanTimerRef.current = setTimeout(async () => {
          await stopScan();

          if (OCR_ON_TIMEOUT) {
            try {
              setStatus("üîé Probeer cijfers te lezen‚Ä¶");
              const digits = await tryOcrFromCurrentFrame({ focusBottom: true });
              if (digits) {
                setBarcodeValue(digits);
                setBarcodeFormat("OCR_DIGITS");
              }
            } catch (e) {
              // ignore OCR error
            }
          }

          openDetails(true);
        }, SCAN_TIMEOUT_MS);

        // Start best available scan loop
        if (isBarcodeDetectorAvailable()) {
          setStatus("‚úÖ Scanner: BarcodeDetector (native)");
          startBarcodeDetectorLoop();
        } else if (window.ZXingBrowser?.BrowserMultiFormatReader) {
          setStatus("‚úÖ Scanner: ZXing (fallback)");
          startZXingLoop();
        } else {
          setStatus("‚ö†Ô∏è Scanner: niet beschikbaar (fallback naar handmatig)");
          setError("Scanner libraries ontbreken. Gebruik handmatig of barcodefoto.");
          await stopScan();
        }
      } catch (e) {
        await stopScan();
        setError("Kon de camera niet starten. Check permissies (Instellingen ‚Üí Safari ‚Üí Camera).");
      }
    }

    function startBarcodeDetectorLoop() {
      const formats = [
        "ean_13","ean_8","code_128","code_39","itf","upc_a","upc_e","qr_code","pdf417","data_matrix"
      ];
      let detector = null;
      try {
        detector = new window.BarcodeDetector({ formats });
      } catch {
        // some implementations require no formats
        detector = new window.BarcodeDetector();
      }

      const loop = async (t) => {
        rafRef.current = requestAnimationFrame(loop);
        const now = performance.now();
        const minInterval = 1000 / DETECT_FPS;
        if (now - lastDetectRef.current < minInterval) return;
        lastDetectRef.current = now;

        const video = videoRef.current;
        if (!video || video.readyState < 2) return;

        const frameCanvas = frameCanvasRef.current || document.createElement("canvas");
        frameCanvasRef.current = frameCanvas;
        const ctx = frameCanvas.getContext("2d");

        // draw full frame
        const w = video.videoWidth;
        const h = video.videoHeight;
        if (!w || !h) return;
        frameCanvas.width = w;
        frameCanvas.height = h;
        ctx.drawImage(video, 0, 0, w, h);

        try {
          const codes = await detector.detect(frameCanvas);
          if (codes && codes.length) {
            const raw = codes[0].rawValue || codes[0].rawValue?.toString?.() || codes[0].value || "";
            const fmt = codes[0].format || "BarcodeDetector";
            if (raw) onScanSuccess(raw, fmt);
          }
        } catch {
          // ignore per-frame errors
        }
      };

      rafRef.current = requestAnimationFrame(loop);
    }

    function startZXingLoop() {
      try {
        zxingReaderRef.current = new window.ZXingBrowser.BrowserMultiFormatReader();
      } catch (e) {
        setError("ZXing kon niet starten: " + (e?.message || e));
        return;
      }

      const video = videoRef.current;
      if (!video) return;

      // decodeFromVideoElement is simplest; iOS can be finicky but we still try.
      zxingReaderRef.current.decodeFromVideoElement(video, (result, err) => {
        if (result) {
          const text = result.getText ? result.getText() : (result.text || "");
          const fmt = result.getBarcodeFormat ? String(result.getBarcodeFormat()) : "ZXing";
          if (text) onScanSuccess(text, fmt);
        }
      });
    }

    async function onScanSuccess(text, fmt) {
      if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
      scanTimerRef.current = null;

      await stopScan();
      setBarcodeValue(String(text || "").trim());
      setBarcodeFormat(fmt || "UNKNOWN");
      openDetails(false);
    }

    function openManual() {
      stopScan();
      setError(null);
      setStatus("");
      setBarcodeFormat("MANUAL_ENTRY");
      openDetails(true);
    }

    async function tryOcrFromCurrentFrame({ focusBottom }) {
      const video = videoRef.current;
      if (!video || video.readyState < 2) return "";

      const w = video.videoWidth;
      const h = video.videoHeight;
      if (!w || !h) return "";

      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");

      // crop region: the central scan box area, optionally bias to bottom (digits under bars)
      const boxW = Math.floor(w * 0.82);
      const boxH = Math.floor(h * 0.44);
      const x = Math.floor((w - boxW) / 2);
      const yCenter = Math.floor((h - boxH) / 2);

      // For digits, take lower part of box
      const y = focusBottom ? Math.floor(yCenter + boxH * 0.35) : yCenter;
      const cropH = focusBottom ? Math.floor(boxH * 0.65) : boxH;

      canvas.width = boxW;
      canvas.height = cropH;

      ctx.drawImage(video, x, y, boxW, cropH, 0, 0, boxW, cropH);

      // Light preprocessing: increase contrast by simple threshold-ish
      const img = ctx.getImageData(0,0,boxW,cropH);
      const d = img.data;
      for (let i=0;i<d.length;i+=4){
        const r=d[i], g=d[i+1], b=d[i+2];
        const gray = 0.299*r + 0.587*g + 0.114*b;
        const v = gray > 160 ? 255 : 0;
        d[i]=d[i+1]=d[i+2]=v;
      }
      ctx.putImageData(img,0,0);

      const digits = await ocrDigitsFromCanvas(canvas);
      return digits;
    }

    async function runOcrNow() {
      setError(null);
      setStatus("üîé Probeer cijfers te lezen‚Ä¶");
      try {
        // If not scanning, start camera first
        if (!scanning) {
          await ensureCamera();
          setScanning(true);
        }
        const digits = await tryOcrFromCurrentFrame({ focusBottom: true });
        if (digits) {
          await stopScan();
          setBarcodeValue(digits);
          setBarcodeFormat("OCR_DIGITS");
          openDetails(false);
        } else {
          setStatus("Geen duidelijke cijfers gevonden ‚Äî vul handmatig in of maak barcodefoto.");
        }
      } catch (e) {
        setError("OCR mislukte: " + (e?.message || e));
      }
    }

    async function handleSave() {
      setError(null);
      if (!storeName.trim()) { setError("Vul een winkelnaam in."); return; }
      if (!barcodeValue.trim() && !barcodeImageId) {
        setError("Vul een barcode-nummer in √≥f voeg een barcodefoto toe.");
        return;
      }

      const card = {
        id: Date.now().toString(),
        storeName: storeName.trim(),
        barcodeValue: barcodeValue.trim(),
        barcodeFormat: barcodeFormat || "MANUAL_ENTRY",
        cardImageId: cardImageId || null,
        barcodeImageId: barcodeImageId || null,
        showTextOnTile: !!showTextOnTile,
        dateAdded: new Date().toISOString(),
        usageCount: 0,
        lastUsed: null
      };

      onSaved(card);

      // reset
      setStoreName("");
      setBarcodeValue("");
      setBarcodeFormat("");
      setCardImageId(null);
      setBarcodeImageId(null);
      setShowTextOnTile(true);
      setStep("scan");
    }

    async function onCropDone({ purpose, blob }) {
      const id = await idbPutImage(blob);
      if (purpose === "card") setCardImageId(id);
      if (purpose === "barcode") setBarcodeImageId(id);
      setCropRequest(null);
    }

    return (
      <div>
        <h2 className="section-title">Nieuw pasje</h2>
        <p className="section-text">
          Scan de barcode. Lukt het niet, dan ga je na enkele seconden automatisch naar handmatige invoer.
          Je kunt ook een kaartfoto en/of barcodefoto toevoegen.
        </p>

        {step === "scan" && (
          <div className="scan-box">
            <div className="field-label">Barcode scannen (camera)</div>

            <div className="scan-view-container">
              <video ref={videoRef} className="scan-video" playsInline muted></video>
              <div className="scan-guides">
                <div className="scan-guides-box"></div>
                <div className="scan-guides-text">Plaats de barcode in het vak ‚Äî houd stil</div>
              </div>
            </div>

            <div className="button-row">
              {!scanning ? (
                <button className="button-secondary" onClick={startScan}>üì∑ Start scannen</button>
              ) : (
                <button className="button-secondary" onClick={stopScan}>‚úã Stop</button>
              )}
              <button className="button-secondary" onClick={openManual}>‚úçÔ∏è Handmatig</button>
              <button className="button-secondary" onClick={runOcrNow}>üîé Lees cijfers</button>
            </div>

            {(status || isBarcodeDetectorAvailable()) && (
              <div className="scan-status">
                <div className="pill">
                  {isBarcodeDetectorAvailable() ? "BarcodeDetector" : "WebKit"}
                </div>
                <div style={{fontSize: 11, color: "#4a5568"}}>{status}</div>
              </div>
            )}

            {error && <div className="error-box">{error}</div>}

            <div className="helper">
              Tip: als scannen lastig is (reflectie/contrast), gebruik <strong>Lees cijfers</strong> of voeg een <strong>barcodefoto</strong> toe.
            </div>
          </div>
        )}

        {step === "details" && (
          <div className="fullscreen-overlay">
            <div className="fullscreen-inner">
              <div className="fullscreen-card">
                <div style={{ fontSize: 18, fontWeight: 800, marginBottom: 6 }}>
                  {barcodeValue ? "Gevonden!" : "Handmatig toevoegen"}
                </div>

                <div className="success-box" style={{ textAlign: "left" }}>
                  {barcodeValue ? (
                    <div>
                      Code: <strong>{barcodeValue}</strong>
                      <div style={{ fontSize: 11, marginTop: 4, color: "#22543d" }}>
                        Bron: {barcodeFormat || "onbekend"} ‚Äî je kunt dit hieronder aanpassen.
                      </div>
                    </div>
                  ) : (
                    <div>Vul de gegevens in. Je kunt ook een barcodefoto opslaan als fallback.</div>
                  )}
                </div>

                <div style={{ marginBottom: 12, textAlign: "left" }}>
                  <div className="field-label">Barcode-nummer (optioneel als je barcodefoto toevoegt)</div>
                  <input
                    className="input"
                    value={barcodeValue}
                    onChange={e => setBarcodeValue(e.target.value)}
                    placeholder="Bijv. 2620630013850"
                    inputMode="numeric"
                  />
                  <div className="helper">Je kunt ook alleen een barcodefoto gebruiken.</div>
                </div>

                <div style={{ marginBottom: 12, textAlign: "left" }}>
                  <div className="field-label">Naam van de winkel</div>
                  <input
                    className="input"
                    value={storeName}
                    onChange={e => setStoreName(e.target.value)}
                    placeholder="Bijv. Albert Heijn, HEMA, Etos‚Ä¶"
                  />
                </div>

                <div style={{ textAlign: "left" }}>
                  <div className="field-label">Afbeeldingen (optioneel)</div>

                  <div className="button-row">
                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üñºÔ∏è Kaartfoto toevoegen
                      <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        onChange={(e) => {
                          const f = e.target.files?.[0];
                          if (!f) return;
                          setCropRequest({ file: f, aspect: 1, purpose: "card", title: "Kaartfoto uitsnijden (vierkant)" });
                          e.target.value = "";
                        }}
                      />
                    </label>

                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üì∏ Barcodefoto toevoegen
                      <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        onChange={(e) => {
                          const f = e.target.files?.[0];
                          if (!f) return;
                          setCropRequest({ file: f, aspect: 4, purpose: "barcode", title: "Barcode uitsnijden (breed)" });
                          e.target.value = "";
                        }}
                      />
                    </label>
                  </div>

                  <div className="toggle-row">
                    <label>Toon tekst op tegel</label>
                    <input type="checkbox" checked={showTextOnTile} onChange={(e) => setShowTextOnTile(e.target.checked)} />
                  </div>

                  <div className="helper">
                    Als je kaartfoto voldoende is, kun je tekst op de tegel uitzetten voor een rustiger scherm.
                  </div>
                </div>

                {error && <div className="error-box">{error}</div>}

                <div className="button-row" style={{ justifyContent: "flex-end" }}>
                  <button className="button-secondary" onClick={() => setStep("scan")}>Annuleer</button>
                  <button className="button-primary" onClick={handleSave}>‚úÖ Opslaan</button>
                </div>
              </div>

              <div style={{ marginTop: 10, fontSize: 11, color: "#e2e8f0" }}>
                Na opslaan vind je het pasje onder <strong>Pasjes</strong>.
              </div>
            </div>

            {cropRequest && (
              <CropperModal
                request={cropRequest}
                onCancel={() => setCropRequest(null)}
                onDone={onCropDone}
              />
            )}
          </div>
        )}
      </div>
    );
  }

  /***********************
   * CropperModal (fixed: much more zoom-out + contain start)
   ***********************/
  function CropperModal({ request, onCancel, onDone }) {
    const { file, aspect, purpose, title } = request;
    const [imgUrl, setImgUrl] = useState(null);
    const imgRef = useRef(null);
    const stageRef = useRef(null);

    const [scale, setScale] = useState(1);
    const [pos, setPos] = useState({ x: 0, y: 0 });
    const [baseScale, setBaseScale] = useState(1);

    const MIN_SCALE = 0.15;
    const MAX_SCALE = 8;

    const pointers = useRef(new Map());
    const lastPinch = useRef(null);

    useEffect(() => {
      const url = URL.createObjectURL(file);
      setImgUrl(url);
      return () => URL.revokeObjectURL(url);
    }, [file]);

    // compute contain baseScale after image loads
    useEffect(() => {
      const img = imgRef.current;
      const stage = stageRef.current;
      if (!img || !stage) return;

      const handle = () => {
        const rect = stage.getBoundingClientRect();
        const nw = img.naturalWidth || 1;
        const nh = img.naturalHeight || 1;

        // hole area size (as stage %)
        const holeW = rect.width * 0.82;
        const holeH = holeW / aspect;
        // contain: make whole photo visible initially, but at least fill hole on one dimension a bit
        const contain = Math.min(rect.width / nw, rect.height / nh); // <<< key change (contain)
        // also ensure the image is not tiny vs hole: aim to cover hole lightly
        const coverHole = Math.max(holeW / nw, holeH / nh);
        const bs = Math.min(Math.max(contain, coverHole * 0.55), 2.5);

        setBaseScale(bs);
        setScale(1);
        setPos({ x: 0, y: 0 });
      };

      if (img.complete) handle();
      else img.onload = handle;

      return () => { if (img) img.onload = null; };
    }, [imgUrl, aspect]);

    function onPointerDown(e) {
      e.preventDefault();
      stageRef.current?.setPointerCapture?.(e.pointerId);
      pointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY });
      lastPinch.current = null;
    }

    function onPointerMove(e) {
      if (!pointers.current.has(e.pointerId)) return;
      const prev = pointers.current.get(e.pointerId);
      pointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

      const pts = Array.from(pointers.current.values());
      if (pts.length === 1) {
        const dx = e.clientX - prev.x;
        const dy = e.clientY - prev.y;
        setPos(p => ({ x: p.x + dx, y: p.y + dy }));
      } else if (pts.length >= 2) {
        const [a, b] = pts;
        const dist = Math.hypot(a.x - b.x, a.y - b.y);
        if (!lastPinch.current) {
          lastPinch.current = { dist };
          return;
        }
        const ratio = dist / (lastPinch.current.dist || dist);
        setScale(s => clamp(s * ratio, MIN_SCALE, MAX_SCALE));
        lastPinch.current = { dist };
      }
    }

    function onPointerUp(e) {
      pointers.current.delete(e.pointerId);
      if (pointers.current.size < 2) lastPinch.current = null;
    }

    function onWheel(e) {
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.06 : 0.94;
      setScale(s => clamp(s * factor, MIN_SCALE, MAX_SCALE));
    }

    function zoomOut() { setScale(s => clamp(s / 1.2, MIN_SCALE, MAX_SCALE)); }
    function zoomIn()  { setScale(s => clamp(s * 1.2, MIN_SCALE, MAX_SCALE)); }
    function reset()   { setScale(1); setPos({x:0,y:0}); }

    async function exportCrop() {
      const imgEl = imgRef.current;
      const stageEl = stageRef.current;
      if (!imgEl || !stageEl) return;

      const stageRect = stageEl.getBoundingClientRect();

      const holeW = stageRect.width * 0.82;
      const holeH = holeW / aspect;
      const holeX = (stageRect.width - holeW) / 2;
      const holeY = (stageRect.height - holeH) / 2;

      // output size
      const outW = purpose === "barcode" ? 1200 : 768;
      const outH = Math.round(outW / aspect);

      const canvas = document.createElement("canvas");
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext("2d");

      const naturalW = imgEl.naturalWidth;
      const naturalH = imgEl.naturalHeight;

      // render on stage: baseScale * scale
      const renderScale = baseScale * scale;
      const renderW = naturalW * renderScale;
      const renderH = naturalH * renderScale;

      const centerX = stageRect.width / 2 + pos.x;
      const centerY = stageRect.height / 2 + pos.y;
      const imgLeft = centerX - renderW / 2;
      const imgTop  = centerY - renderH / 2;

      // stage->image coords
      const sx = (holeX - imgLeft) / renderScale;
      const sy = (holeY - imgTop)  / renderScale;
      const sWidth  = holeW / renderScale;
      const sHeight = holeH / renderScale;

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,outW,outH);
      ctx.drawImage(imgEl, sx, sy, sWidth, sHeight, 0, 0, outW, outH);

      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/jpeg", 0.9));
      if (!blob) return;
      onDone({ purpose, blob });
    }

    return (
      <div className="fullscreen-overlay" style={{ zIndex: 60 }}>
        <div className="fullscreen-inner">
          <div className="fullscreen-card">
            <div style={{ fontSize: 16, fontWeight: 800, marginBottom: 10 }}>{title}</div>

            <div
              ref={stageRef}
              className="crop-stage"
              onPointerDown={onPointerDown}
              onPointerMove={onPointerMove}
              onPointerUp={onPointerUp}
              onPointerCancel={onPointerUp}
              onWheel={onWheel}
            >
              {imgUrl && (
                <img
                  ref={imgRef}
                  src={imgUrl}
                  alt="crop"
                  draggable={false}
                  style={{ transform: `translate(-50%, -50%) translate(${pos.x}px, ${pos.y}px) scale(${baseScale * scale})` }}
                />
              )}

              <div className="crop-mask">
                <div
                  className="crop-hole"
                  style={{
                    width: `${82}%`,
                    height: `${(0.82 / aspect) * 100}%`
                  }}
                ></div>
              </div>
            </div>

            <div className="crop-controls">
              <div className="pill">Zoomen: pinch / knoppen</div>
              <div style={{display:"flex", gap:8}}>
                <button className="button-secondary" onClick={zoomOut}>‚ûñ</button>
                <button className="button-secondary" onClick={reset}>üîÑ Reset</button>
                <button className="button-secondary" onClick={zoomIn}>‚ûï</button>
              </div>
            </div>

            <div className="helper" style={{ marginTop: 10 }}>
              Sleep om te positioneren. Je kunt nu veel verder uitzoomen.
            </div>

            <div className="button-row" style={{ justifyContent: "flex-end" }}>
              <button className="button-secondary" onClick={onCancel}>Annuleer</button>
              <button className="button-primary" onClick={exportCrop}>‚úÖ Gebruik uitsnede</button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  /***********************
   * CardsTab
   ***********************/
  function CardsTab({ cards, sortBy, onOpenCard }) {
    const [search, setSearch] = useState("");
    const filtered = cards.filter(c => (c.storeName || "").toLowerCase().includes(search.toLowerCase()));

    return (
      <div>
        <h2 className="section-title">Mijn pasjes</h2>
        <p className="section-text">Tik op een pasje om te openen.</p>

        <div style={{ marginBottom: 12 }}>
          <input className="input" placeholder="Zoek op winkelnaam..." value={search} onChange={e => setSearch(e.target.value)} />
        </div>

        {filtered.length === 0 ? (
          <div className="empty-state">
            <div className="empty-icon">üí≥</div>
            <div>Nog geen pasjes. Voeg er √©√©n toe via <strong>Scan</strong>.</div>
          </div>
        ) : (
          <div className="card-grid">
            {filtered.map(card => (
              <CardTile key={card.id} card={card} sortBy={sortBy} onClick={() => onOpenCard(card)} />
            ))}
          </div>
        )}
      </div>
    );
  }

  function CardTile({ card, sortBy, onClick }) {
    const [imgUrl, setImgUrl] = useState(null);

    useEffect(() => {
      let url = null;
      let cancelled = false;
      (async () => {
        if (card.cardImageId) {
          const blob = await idbGetImage(card.cardImageId);
          if (cancelled) return;
          url = blobToObjectUrl(blob);
          setImgUrl(url);
        } else {
          setImgUrl(null);
        }
      })();
      return () => {
        cancelled = true;
        if (url) URL.revokeObjectURL(url);
      };
    }, [card.cardImageId]);

    const showText = card.showTextOnTile !== false;

    return (
      <div className="card-item" onClick={onClick}>
        {imgUrl ? (
          <>
            <img className="card-image" src={imgUrl} alt={card.storeName || "kaart"} />
            {showText && (
              <div className="card-overlay">
                <div className="card-title">{card.storeName}</div>
                <div className="card-sub">Tik om te openen</div>
                {sortBy === "mostUsed" && (
                  <div className="card-sub" style={{ marginTop: 4 }}>
                    {(card.usageCount || 0) ? `${card.usageCount}√ó gebruikt` : "Nog niet gebruikt"}
                  </div>
                )}
              </div>
            )}
          </>
        ) : (
          <div className="card-plain-center">
            <div style={{ fontSize: 26 }}>üí≥</div>
            <div className="card-title" style={{ color: "#1a202c" }}>{card.storeName}</div>
            <div className="card-sub">Tik om te openen</div>
          </div>
        )}
      </div>
    );
  }

  /***********************
   * SettingsTab (edit supports adding images after the fact)
   ***********************/
  function SettingsTab({ cards, sortBy, setSortBy, onDeleteCard, onEditCard }) {
    const [editingCard, setEditingCard] = useState(null);
    const [editName, setEditName] = useState("");
    const [editCode, setEditCode] = useState("");
    const [editShowText, setEditShowText] = useState(true);

    const [cropRequest, setCropRequest] = useState(null); // used for edit too
    const pendingPurposeRef = useRef(null);

    function openEdit(card) {
      setEditingCard(card);
      setEditName(card.storeName || "");
      setEditCode(card.barcodeValue || "");
      setEditShowText(card.showTextOnTile !== false);
    }

    function closeEdit() {
      setEditingCard(null);
      setCropRequest(null);
      pendingPurposeRef.current = null;
    }

    async function saveEdit() {
      if (!editingCard) return;
      await onEditCard(editingCard.id, {
        storeName: editName.trim() || editingCard.storeName,
        barcodeValue: editCode.trim(),
        showTextOnTile: !!editShowText
      });
      closeEdit();
    }

    function exportData() {
      const data = { cards, sortBy, exportedAt: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pashie-backup.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function importData(ev) {
      const file = ev.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          if (!data.cards || !Array.isArray(data.cards)) {
            alert("Ongeldig bestand.");
            return;
          }
          saveStorage("pashie_cards", data.cards);
          saveStorage("pashie_sort", data.sortBy || "alphabetical");
          location.reload();
        } catch {
          alert("Kon het bestand niet lezen.");
        }
      };
      reader.readAsText(file);
    }

    async function onCropDone({ purpose, blob }) {
      if (!editingCard) return;
      const newId = await idbPutImage(blob);
      if (purpose === "card") {
        await onEditCard(editingCard.id, { cardImageId: newId });
      } else if (purpose === "barcode") {
        await onEditCard(editingCard.id, { barcodeImageId: newId });
      }
      setCropRequest(null);
    }

    async function removeImage(which) {
      if (!editingCard) return;
      if (which === "card") {
        await onEditCard(editingCard.id, { cardImageId: null });
      } else {
        await onEditCard(editingCard.id, { barcodeImageId: null });
      }
      // Note: old image is deleted in onEditCard (App.updateCard) when replaced; for null we delete explicitly here
      // We'll delete explicitly now:
      try {
        if (which === "card" && editingCard.cardImageId) await idbDeleteImage(editingCard.cardImageId);
        if (which === "barcode" && editingCard.barcodeImageId) await idbDeleteImage(editingCard.barcodeImageId);
      } catch {}
      // Update local edit modal state with fresh card object on next render from parent
    }

    return (
      <div>
        <h2 className="section-title">Instellingen</h2>
        <p className="section-text">Sortering, back-up, en pasjesbeheer.</p>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Sortering</div>
          <div className="button-row">
            <button className="button-secondary" onClick={() => setSortBy("alphabetical")} style={{ background: sortBy==="alphabetical" ? "#e6fffa" : "#edf2f7" }}>A ‚Üí Z</button>
            <button className="button-secondary" onClick={() => setSortBy("date")} style={{ background: sortBy==="date" ? "#e6fffa" : "#edf2f7" }}>Nieuwste</button>
            <button className="button-secondary" onClick={() => setSortBy("mostUsed")} style={{ background: sortBy==="mostUsed" ? "#e6fffa" : "#edf2f7" }}>Meest gebruikt</button>
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Back-up & herstel</div>
          <div className="button-row">
            <button className="button-secondary" onClick={exportData}>üíæ Exporteer</button>
            <label className="button-secondary" style={{ cursor: "pointer" }}>
              üìÇ Importeer
              <input type="file" accept="application/json" style={{ display: "none" }} onChange={importData} />
            </label>
          </div>
          <div className="helper">Let op: foto‚Äôs staan in IndexedDB en gaan nog niet mee in de JSON-export.</div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Pasjes beheren</div>
          {cards.length === 0 ? (
            <div className="helper">Nog geen pasjes opgeslagen.</div>
          ) : (
            <div style={{ maxHeight: 320, overflowY: "auto" }}>
              {cards
                .slice()
                .sort((a,b) => (a.storeName||"").localeCompare(b.storeName||""))
                .map(card => (
                  <div key={card.id}
                       style={{
                         display: "flex", alignItems: "center", justifyContent: "space-between",
                         padding: "8px 0", borderBottom: "1px solid #e2e8f0", fontSize: 13
                       }}>
                    <div style={{ fontWeight: 800 }}>{card.storeName}</div>
                    <div style={{ display: "flex", gap: 8 }}>
                      <button className="button-secondary" style={{ padding: "8px 12px", fontSize: 12 }} onClick={() => openEdit(card)}>
                        ‚úèÔ∏è Bewerken
                      </button>
                      <button className="button-danger" style={{ padding: "8px 12px", fontSize: 12 }} onClick={() => {
                        if (confirm(`Pasje voor "${card.storeName}" verwijderen? (ook foto‚Äôs worden verwijderd)`)) onDeleteCard(card.id);
                      }}>
                        Verwijder
                      </button>
                    </div>
                  </div>
                ))}
            </div>
          )}
        </div>

        {editingCard && (
          <div className="fullscreen-overlay">
            <div className="fullscreen-inner">
              <div className="fullscreen-card" style={{ textAlign: "left" }}>
                <div style={{ fontSize: 16, fontWeight: 800, marginBottom: 10, textAlign:"center" }}>Pasje bewerken</div>

                <div style={{ marginBottom: 12 }}>
                  <div className="field-label">Winkelnaam</div>
                  <input className="input" value={editName} onChange={e => setEditName(e.target.value)} />
                </div>

                <div style={{ marginBottom: 12 }}>
                  <div className="field-label">Barcode-nummer</div>
                  <input className="input" value={editCode} onChange={e => setEditCode(e.target.value)} inputMode="numeric" />
                  <div className="helper">Geen nummer? Voeg een barcodefoto toe.</div>
                </div>

                <div className="toggle-row" style={{ marginTop: 0 }}>
                  <label>Toon tekst op tegel</label>
                  <input type="checkbox" checked={editShowText} onChange={(e) => setEditShowText(e.target.checked)} />
                </div>

                <div style={{ marginTop: 12 }}>
                  <div className="field-label">Foto‚Äôs</div>
                  <div className="button-row">
                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üñºÔ∏è Kaartfoto
                      <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        onChange={(e) => {
                          const f = e.target.files?.[0];
                          if (!f) return;
                          setCropRequest({ file: f, aspect: 1, purpose: "card", title: "Kaartfoto uitsnijden (vierkant)" });
                          e.target.value = "";
                        }}
                      />
                    </label>

                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üì∏ Barcodefoto
                      <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        onChange={(e) => {
                          const f = e.target.files?.[0];
                          if (!f) return;
                          setCropRequest({ file: f, aspect: 4, purpose: "barcode", title: "Barcode uitsnijden (breed)" });
                          e.target.value = "";
                        }}
                      />
                    </label>

                    <button className="button-secondary" onClick={() => removeImage("card")}>üóëÔ∏è Kaartfoto weg</button>
                    <button className="button-secondary" onClick={() => removeImage("barcode")}>üóëÔ∏è Barcodefoto weg</button>
                  </div>
                  <div className="helper">Je kunt nu ook bij bestaande pasjes foto‚Äôs toevoegen of vervangen.</div>
                </div>

                <div className="button-row" style={{ justifyContent: "flex-end" }}>
                  <button className="button-secondary" onClick={closeEdit}>Annuleer</button>
                  <button className="button-primary" onClick={saveEdit}>üíæ Opslaan</button>
                </div>
              </div>
            </div>

            {cropRequest && (
              <CropperModal
                request={cropRequest}
                onCancel={() => setCropRequest(null)}
                onDone={onCropDone}
              />
            )}
          </div>
        )}
      </div>
    );
  }

  /***********************
   * HelpTab (updated for new features)
   ***********************/
  function HelpTab() {
    return (
      <div>
        <h2 className="section-title">Handleiding</h2>
        <p className="section-text">Scannen, foto‚Äôs toevoegen en installeren als PWA.</p>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Pasje toevoegen</div>
          <div className="helper">
            Ga naar <strong>Scan</strong> ‚Üí <strong>Start scannen</strong>. Als er niets wordt gevonden, ga je automatisch naar handmatige invoer.
            Je kunt ook <strong>Lees cijfers</strong> gebruiken (OCR) of een <strong>barcodefoto</strong> toevoegen.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Foto‚Äôs (kaart / barcode)</div>
          <div className="helper">
            Je kunt een <strong>kaartfoto</strong> opslaan (tegel wordt dan visueel herkenbaar) en/of een <strong>barcodefoto</strong> als fallback
            (handig bij pasjes zonder cijferreeks). In de cropper kun je slepen en ver in/uit zoomen.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Tekst op tegels</div>
          <div className="helper">
            Per pasje kun je kiezen of de tekst op de tegel zichtbaar is. Als je kaartfoto genoeg is, zet je dit uit voor een rustig overzicht.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Bestaande pasjes aanpassen</div>
          <div className="helper">
            Ga naar <strong>Instellingen</strong> ‚Üí <strong>Pasjes beheren</strong> ‚Üí <strong>Bewerken</strong>. Daar kun je naam, barcode en foto‚Äôs wijzigen of toevoegen.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">PWA installeren</div>
          <div className="helper">
            <strong>iPhone (Safari):</strong> Deel-knop ‚Üí ‚ÄúZet op beginscherm‚Äù.<br/>
            <strong>Android (Chrome):</strong> menu (‚ãÆ) ‚Üí ‚ÄúInstalleren‚Äù / ‚ÄúToevoegen aan startscherm‚Äù.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Back-up</div>
          <div className="helper">
            De JSON-export bevat pasjesdata, maar nog niet de foto‚Äôs uit IndexedDB. (Kan later toegevoegd worden.)
          </div>
        </div>
      </div>
    );
  }

  /***********************
   * BarcodeOverlay
   ***********************/
  function BarcodeOverlay({ card, onClose }) {
    const svgRef = useRef(null);
    const [barcodeImgUrl, setBarcodeImgUrl] = useState(null);

    useEffect(() => {
      let url = null;
      let cancelled = false;
      (async () => {
        if (card.barcodeImageId) {
          const blob = await idbGetImage(card.barcodeImageId);
          if (cancelled) return;
          url = blobToObjectUrl(blob);
          setBarcodeImgUrl(url);
        } else {
          setBarcodeImgUrl(null);
        }
      })();
      return () => {
        cancelled = true;
        if (url) URL.revokeObjectURL(url);
      };
    }, [card.barcodeImageId]);

    useEffect(() => {
      const el = svgRef.current;
      if (!el) return;
      while (el.firstChild) el.removeChild(el.firstChild);
      if (!card.barcodeValue) return;

      if (typeof JsBarcode === "function") {
        try {
          JsBarcode(el, card.barcodeValue, {
            format: "CODE128",
            width: 2,
            height: 100,
            displayValue: true,
            margin: 10,
            fontSize: 18
          });
        } catch {}
      }
    }, [card.barcodeValue]);

    const showGenerated = !!card.barcodeValue;

    return (
      <div className="fullscreen-overlay">
        <div className="fullscreen-inner">
          <div className="fullscreen-close-row">
            <button className="button-secondary" onClick={onClose}>‚¨ÖÔ∏é Terug</button>
            <div className="chip">üîç Kassascanner</div>
          </div>

          <div className="fullscreen-card">
            <div style={{ fontSize: 18, fontWeight: 800, marginBottom: 6 }}>{card.storeName}</div>

            {showGenerated ? (
              <>
                <svg ref={svgRef} className="barcode-svg" preserveAspectRatio="xMidYMid meet"></svg>
                <div className="barcode-value">{card.barcodeValue}</div>
              </>
            ) : barcodeImgUrl ? (
              <>
                <div style={{ fontSize: 12, color: "#4a5568", marginBottom: 8 }}>Barcodefoto (fallback)</div>
                <img
                  src={barcodeImgUrl}
                  alt="barcode foto"
                  style={{
                    width: "100%",
                    height: "160px",
                    objectFit: "contain",
                    background: "#fff",
                    borderRadius: "12px",
                    border: "1px solid #e2e8f0",
                    padding: "8px"
                  }}
                />
                <div className="helper" style={{ marginTop: 8 }}>
                  Tip: zet je schermhelderheid hoog voor betere leesbaarheid.
                </div>
              </>
            ) : (
              <div className="error-box">Geen barcode-nummer en geen barcodefoto opgeslagen.</div>
            )}
          </div>

          <div style={{ marginTop: 10, fontSize: 11, color: "#e2e8f0" }}>
            Tip: houd je telefoon stabiel onder de scanner.
          </div>
        </div>
      </div>
    );
  }

  ReactDOM.render(<App />, document.getElementById("root"));
</script>
</body>
</html>
