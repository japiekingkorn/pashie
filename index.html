<!DOCTYPE html>
<html lang="nl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Pashie</title>

  <!-- PWA -->
  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#1a7b7b" />
  <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192.png" />
  <link rel="apple-touch-icon" href="icons/icon-192.png" />

  <!-- React & Babel -->
  <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <!-- ZXing (scanner) -->
  <script src="https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/umd/index.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js"></script>

  <!-- JsBarcode (generate barcode) -->
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.5/dist/JsBarcode.all.min.js"></script>

  <style>
    :root {
      --primary: #1a7b7b;
      --bg: #f5f7fb;
      --text: #1a202c;
      --muted: #718096;
      --danger: #c53030;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    #root {
      max-width: 480px;
      margin: 0 auto;
      min-height: 100vh;
      background: #fff;
      display: flex;
      flex-direction: column;
      box-shadow: 0 0 30px rgba(0,0,0,0.08);
      position: relative;
    }
    .app { display: flex; flex-direction: column; min-height: 100vh; }
    .content { flex: 1; overflow-y: auto; padding: 16px; }

    .header {
      padding: 14px 18px;
      border-bottom: 1px solid #e2e8f0;
      position: sticky; top: 0; z-index: 5;
      background: #ffffffcc;
      backdrop-filter: blur(10px);
      padding-top: calc(14px + env(safe-area-inset-top));
    }
    .header-inner { display: flex; align-items: center; gap: 12px; }
    .header-logo-box {
      width: 40px; height: 40px;
      border-radius: 14px;
      background: #e6fffa;
      display: flex; align-items: center; justify-content: center;
      overflow: hidden;
      box-shadow: 0 4px 10px rgba(26,123,123,0.25);
      flex-shrink: 0;
    }
    .header-logo-img { width: 100%; height: 100%; object-fit: cover; }
    .header-title { font-size: 19px; font-weight: 800; margin: 0; letter-spacing: 0.08em; text-transform: uppercase; }
    .header-subtitle { font-size: 11px; color: var(--muted); margin: 2px 0 0; }

    .bottom-nav {
      display: flex;
      border-top: 1px solid #e2e8f0;
      background: #fff;
      padding-top: 6px;
      padding-bottom: calc(8px + env(safe-area-inset-bottom));
      position: sticky; bottom: 0; z-index: 6;
    }
    .nav-button {
      flex: 1;
      padding: 10px 4px;
      border: none;
      background: none;
      font-size: 13px;
      color: var(--muted);
      display: flex; flex-direction: column; align-items: center; gap: 4px;
      cursor: pointer;
    }
    .nav-button.nav-active { color: var(--primary); font-weight: 700; }
    .nav-icon { font-size: 20px; }

    .section-title { font-size: 16px; font-weight: 700; margin: 0 0 4px; }
    .section-text { font-size: 12px; color: var(--muted); margin: 0 0 12px; }

    .field-label { font-size: 12px; font-weight: 700; margin-bottom: 4px; }
    .input {
      width: 100%;
      padding: 10px 12px;
      font-size: 15px;
      border-radius: 10px;
      border: 1px solid #e2e8f0;
      outline: none;
    }
    .input:focus {
      border-color: var(--primary);
      box-shadow: 0 0 0 1px rgba(26,123,123,0.25);
    }
    .helper { font-size: 11px; color: var(--muted); margin-top: 5px; }

    .button-primary {
      background: var(--primary);
      color: #fff;
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .button-secondary {
      background: #edf2f7;
      color: #2d3748;
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
    }
    .button-danger {
      background: #fff5f5;
      color: var(--danger);
      border: none;
      border-radius: 999px;
      padding: 10px 16px;
      font-size: 14px;
      font-weight: 700;
      cursor: pointer;
    }
    .button-row { display: flex; gap: 8px; margin-top: 12px; flex-wrap: wrap; }

    .card-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 10px; }
    .card-item {
      border-radius: 14px;
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      cursor: pointer;
      display: flex; flex-direction: column;
      align-items: stretch; justify-content: space-between;
      aspect-ratio: 1 / 1;
      overflow: hidden;
      position: relative;
    }
    .card-image {
      position: absolute; inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
    }
    .card-overlay {
      position: absolute;
      left: 0; right: 0; bottom: 0;
      padding: 10px;
      background: linear-gradient(to top, rgba(0,0,0,0.68), rgba(0,0,0,0));
      color: #fff;
    }
    .card-title { font-size: 16px; font-weight: 800; line-height: 1.1; margin-bottom: 4px; }
    .card-sub { font-size: 12px; opacity: 0.92; }
    .card-plain-center {
      padding: 12px;
      height: 100%;
      display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      text-align: center;
      gap: 6px;
    }

    .empty-state {
      text-align: center;
      padding: 40px 16px;
      color: var(--muted);
      font-size: 13px;
    }
    .empty-icon { font-size: 38px; margin-bottom: 8px; }

    .scan-box {
      border-radius: 12px;
      border: 1px dashed #cbd5e0;
      padding: 12px;
      background: #f7fafc;
      margin-bottom: 16px;
    }
    .scan-view-container {
      position: relative;
      margin-top: 8px;
      border-radius: 12px;
      overflow: hidden;
      background: #000;
      border: 1px solid #111;
      height: 280px;
      min-height: 280px;
    }
    video.scan-video {
      width: 100%;
      height: 280px;
      object-fit: cover;
      display: block;
      background: #000;
    }
    .scan-guides {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      pointer-events: none;
    }
    .scan-guides-box {
      width: 82%;
      height: 44%;
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.95);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.45);
    }
    .scan-guides-text {
      position: absolute;
      bottom: 8px; left: 0; right: 0;
      text-align: center;
      font-size: 11px;
      color: #f7fafc;
      text-shadow: 0 1px 2px rgba(0,0,0,0.7);
    }

    .error-box {
      margin-top: 8px;
      padding: 10px;
      border-radius: 10px;
      background: #fff5f5;
      color: var(--danger);
      font-size: 12px;
      white-space: pre-wrap;
    }
    .success-box {
      margin-bottom: 14px;
      padding: 10px;
      border-radius: 10px;
      background: #e6fffa;
      color: #22543d;
      font-size: 13px;
    }

    /* overlays / modals */
    .fullscreen-overlay {
      position: fixed; inset: 0;
      background: rgba(15,23,42,0.95);
      display: flex; align-items: center; justify-content: center;
      z-index: 50;
    }
    .fullscreen-inner {
      max-width: 420px;
      width: 100%;
      padding: 22px 16px;
      text-align: center;
      color: #f7fafc;
    }
    .fullscreen-card {
      background: #fff;
      border-radius: 18px;
      padding: 16px;
      color: #1a202c;
      box-shadow: 0 14px 30px rgba(0,0,0,0.5);
    }
    .fullscreen-close-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      font-size: 12px;
      color: #e2e8f0;
    }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      border-radius: 999px;
      background: rgba(15,23,42,0.4);
      font-size: 11px;
    }

    .barcode-svg { width: 100%; height: 140px; }
    .barcode-value {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 16px;
      letter-spacing: 0.18em;
      margin-top: 10px;
    }

    /* Cropper */
    .crop-stage {
      position: relative;
      width: 100%;
      height: 360px;
      background: #0b1220;
      border-radius: 14px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
    }
    .crop-stage img {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      transform-origin: center center;
      user-select: none;
      touch-action: none;
      -webkit-user-drag: none;
    }
    .crop-mask {
      position: absolute; inset: 0;
      pointer-events: none;
      display: flex; align-items: center; justify-content: center;
    }
    .crop-hole {
      border-radius: 12px;
      border: 2px solid rgba(255,255,255,0.95);
      box-shadow: 0 0 0 9999px rgba(0,0,0,0.55);
    }
    .crop-controls {
      display: flex;
      gap: 8px;
      justify-content: center;
      margin-top: 10px;
      flex-wrap: wrap;
    }
    .toggle-row {
      display: flex; align-items: center; justify-content: space-between;
      gap: 10px;
      padding: 10px 12px;
      border-radius: 12px;
      background: #f7fafc;
      border: 1px solid #e2e8f0;
      margin-top: 10px;
    }
    .toggle-row label { font-size: 13px; font-weight: 700; }
    .toggle-row input { transform: scale(1.1); }

    /* Splashscreen */
    .splash-overlay {
      position: absolute; inset: 0;
      background: radial-gradient(circle at top, #ff6b6b 0, #1a7b7b 45%, #0b2545 100%);
      display: flex; align-items: center; justify-content: center;
      z-index: 100;
      color: #f7fafc;
    }
    .splash-inner { text-align: center; padding: 24px; }
    .splash-logo-circle {
      width: 96px; height: 96px; border-radius: 999px;
      background: rgba(15,23,42,0.3);
      border: 2px solid rgba(255,255,255,0.8);
      display: flex; align-items: center; justify-content: center;
      margin: 0 auto 16px;
      overflow: hidden;
      box-shadow: 0 18px 40px rgba(0,0,0,0.5);
    }
    .splash-logo-circle img { width: 100%; height: 100%; object-fit: cover; }
    .splash-name {
      font-size: 22px;
      font-weight: 800;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      text-indent: 0.24em;
      margin-bottom: 6px;
    }
    .splash-subtitle {
      font-size: 12px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      opacity: 0.9;
      margin-bottom: 10px;
    }
    .splash-tagline { font-size: 11px; opacity: 0.85; }
  </style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
  const { useEffect, useMemo, useRef, useState } = React;

  // --- Script loader (fallback for iOS/CDN quirks) ---
  const __loadedScripts = new Set();
  function loadScriptOnce(url) {
    return new Promise((resolve, reject) => {
      if (__loadedScripts.has(url)) return resolve(true);
      const s = document.createElement('script');
      s.src = url;
      s.async = true;
      s.onload = () => { __loadedScripts.add(url); resolve(true); };
      s.onerror = () => reject(new Error('Failed to load ' + url));
      document.head.appendChild(s);
    });
  }

  async function ensureScannerLibs() {
    // ZXing (try multiple CDNs)
    if (!(window.ZXingBrowser && window.ZXingBrowser.BrowserMultiFormatReader)) {
      const zxingUrls = [
        "https://cdn.jsdelivr.net/npm/@zxing/browser@0.1.5/umd/index.min.js",
        "https://unpkg.com/@zxing/browser@0.1.5/umd/index.min.js"
      ];
      for (const u of zxingUrls) {
        try { await loadScriptOnce(u); } catch {}
        if (window.ZXingBrowser && window.ZXingBrowser.BrowserMultiFormatReader) break;
      }
    }
    // Quagga2 (try multiple CDNs)
    if (!(window.Quagga && window.Quagga.init)) {
      const quaggaUrls = [
        "https://cdn.jsdelivr.net/npm/@ericblade/quagga2@1.8.4/dist/quagga.min.js",
        "https://unpkg.com/@ericblade/quagga2@1.8.4/dist/quagga.min.js"
      ];
      for (const u of quaggaUrls) {
        try { await loadScriptOnce(u); } catch {}
        if (window.Quagga && window.Quagga.init) break;
      }
    }
    return {
      hasZXing: !!(window.ZXingBrowser && window.ZXingBrowser.BrowserMultiFormatReader),
      hasQuagga: !!(window.Quagga && window.Quagga.init)
    };
  }

  function loadStorage(key, fallback) {
    try { const v = localStorage.getItem(key); return v ? JSON.parse(v) : fallback; } catch { return fallback; }
  }
  function saveStorage(key, value) { try { localStorage.setItem(key, JSON.stringify(value)); } catch {} }

  const DB_NAME = "pashie_db";
  const DB_VERSION = 1;
  const STORE_IMAGES = "images";

  function idbOpen() {
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, DB_VERSION);
      req.onupgradeneeded = () => {
        const db = req.result;
        if (!db.objectStoreNames.contains(STORE_IMAGES)) db.createObjectStore(STORE_IMAGES, { keyPath: "id" });
      };
      req.onsuccess = () => resolve(req.result);
      req.onerror = () => reject(req.error);
    });
  }

  async function idbPutImage(blob) {
    const db = await idbOpen();
    const id = "img_" + Date.now() + "_" + Math.random().toString(16).slice(2);
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_IMAGES, "readwrite");
      tx.objectStore(STORE_IMAGES).put({ id, blob });
      tx.oncomplete = () => resolve(id);
      tx.onerror = () => reject(tx.error);
    });
  }
  async function idbGetImage(id) {
    if (!id) return null;
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_IMAGES, "readonly");
      const req = tx.objectStore(STORE_IMAGES).get(id);
      req.onsuccess = () => resolve(req.result ? req.result.blob : null);
      req.onerror = () => reject(req.error);
    });
  }
  async function idbDeleteImage(id) {
    if (!id) return;
    const db = await idbOpen();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_IMAGES, "readwrite");
      tx.objectStore(STORE_IMAGES).delete(id);
      tx.oncomplete = () => resolve();
      tx.onerror = () => reject(tx.error);
    });
  }

  function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }
  function blobToObjectUrl(blob) { return blob ? URL.createObjectURL(blob) : null; }

  function App() {
    const [activeTab, setActiveTab] = useState("cards");
    const [cards, setCards] = useState(() => loadStorage("pashie_cards", []));
    const [sortBy, setSortBy] = useState(() => loadStorage("pashie_sort", "alphabetical"));
    const [selectedCard, setSelectedCard] = useState(null);
    const [showSplash, setShowSplash] = useState(true);

    useEffect(() => saveStorage("pashie_cards", cards), [cards]);
    useEffect(() => saveStorage("pashie_sort", sortBy), [sortBy]);
    useEffect(() => { const t = setTimeout(() => setShowSplash(false), 2600); return () => clearTimeout(t); }, []);

    function addCard(card) { setCards(prev => [...prev, card]); }
    function updateCard(id, updates) { setCards(prev => prev.map(c => (c.id === id ? { ...c, ...updates } : c))); }
    function markUsed(id) {
      setCards(prev => prev.map(c => c.id === id ? { ...c, lastUsed: new Date().toISOString(), usageCount: (c.usageCount || 0) + 1 } : c));
    }
    async function deleteCard(id) {
      const c = cards.find(x => x.id === id);
      if (c?.cardImageId) await idbDeleteImage(c.cardImageId);
      if (c?.barcodeImageId) await idbDeleteImage(c.barcodeImageId);
      setCards(prev => prev.filter(x => x.id !== id));
    }
    function sortedCards() {
      const arr = [...cards];
      if (sortBy === "alphabetical") return arr.sort((a,b) => (a.storeName || "").localeCompare(b.storeName || ""));
      if (sortBy === "date") return arr.sort((a,b) => new Date(b.dateAdded) - new Date(a.dateAdded));
      if (sortBy === "mostUsed") return arr.sort((a,b) => (b.usageCount||0) - (a.usageCount||0));
      return arr;
    }

    return (
      <div className="app">
        {showSplash && (
          <div className="splash-overlay">
            <div className="splash-inner">
              <div className="splash-logo-circle"><img src="icons/icon-192.png" alt="Pashie" /></div>
              <div className="splash-name">Pashie</div>
              <div className="splash-subtitle">Membership cards in your pocket</div>
              <div className="splash-tagline">üí≥ E√©n plek voor al je pasjes ‚Äì lokaal, simpel, snel.</div>
            </div>
          </div>
        )}

        <header className="header">
          <div className="header-inner">
            <div className="header-logo-box"><img className="header-logo-img" src="icons/icon-192.png" alt="Pashie" /></div>
            <div style={{display:"flex", flexDirection:"column"}}>
              <div className="header-title">Pashie</div>
              <div className="header-subtitle">Je klantenkaarten altijd bij de hand ‚Äî zonder account.</div>
            </div>
          </div>
        </header>

        <main className="content">
          {activeTab === "scan" && <ScanTab onSaved={(card) => { addCard(card); setActiveTab("cards"); }} />}
          {activeTab === "cards" && <CardsTab cards={sortedCards()} sortBy={sortBy} onOpenCard={(card) => { setSelectedCard(card); markUsed(card.id); }} />}
          {activeTab === "settings" && <SettingsTab cards={cards} sortBy={sortBy} setSortBy={setSortBy} onDeleteCard={deleteCard} onEditCard={updateCard} />}
          {activeTab === "help" && <HelpTab />}
        </main>

        <nav className="bottom-nav">
          <button className={"nav-button " + (activeTab === "scan" ? "nav-active" : "")} onClick={() => setActiveTab("scan")}><div className="nav-icon">üì∑</div><span>Scan</span></button>
          <button className={"nav-button " + (activeTab === "cards" ? "nav-active" : "")} onClick={() => setActiveTab("cards")}><div className="nav-icon">üí≥</div><span>Pasjes</span></button>
          <button className={"nav-button " + (activeTab === "settings" ? "nav-active" : "")} onClick={() => setActiveTab("settings")}><div className="nav-icon">‚öôÔ∏è</div><span>Instellingen</span></button>
          <button className={"nav-button " + (activeTab === "help" ? "nav-active" : "")} onClick={() => setActiveTab("help")}><div className="nav-icon">‚ùì</div><span>Help</span></button>
        </nav>

        {selectedCard && <BarcodeOverlay card={selectedCard} onClose={() => setSelectedCard(null)} />}
      </div>
    );
  }

  function ScanTab({ onSaved }) {
    const SCAN_TIMEOUT_MS = 6000;

    const [step, setStep] = useState("scan"); // scan | details
    const [scanning, setScanning] = useState(false);
    const [usingQuagga, setUsingQuagga] = useState(false);
    const [error, setError] = useState(null);

    const [storeName, setStoreName] = useState("");
    const [barcodeValue, setBarcodeValue] = useState("");
    const [barcodeFormat, setBarcodeFormat] = useState("");

    const [cardImageId, setCardImageId] = useState(null);
    const [barcodeImageId, setBarcodeImageId] = useState(null);
    const [showTextOnTile, setShowTextOnTile] = useState(true);

    const [cropRequest, setCropRequest] = useState(null); // {file, aspect, purpose, title}
    const scanTimerRef = useRef(null);

    const videoRef = useRef(null);
    const quaggaTargetRef = useRef(null);
    const codeReaderRef = useRef(null);
    const streamRef = useRef(null);

    useEffect(() => () => { stopScan(); }, []);

    async function stopScan() {
      if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
      scanTimerRef.current = null;

      try {
        if (codeReaderRef.current) {
          try { codeReaderRef.current.reset(); } catch {}
        }
      } catch {}

      // Stop Quagga if running
      try { if (window.Quagga && window.Quagga.stop) window.Quagga.stop(); } catch {}

      if (streamRef.current) {
        try { streamRef.current.getTracks().forEach(t => t.stop()); } catch {}
        streamRef.current = null;
      }

      setUsingQuagga(false);
      setScanning(false);
    }

    async function startScan() {
      setError(null);
      setBarcodeValue("");
      setBarcodeFormat("");
      setStep("scan");
      setUsingQuagga(false);

      // Ensure scanner libs are present (multi-CDN)
      const libs = await ensureScannerLibs();

      // If neither engine exists, explain clearly.
      if (!libs.hasZXing && !libs.hasQuagga) {
        setError("Scanner libraries ontbreken (ZXing/Quagga). Dit is vaak een iOS-cache/CDN issue. Gebruik handmatig of barcodefoto.");
        return;
      }

      // Start camera (shared for both engines)
      let stream = null;
      try {
        const constraints = { video: { facingMode: { ideal: "environment" } }, audio: false };
        stream = await navigator.mediaDevices.getUserMedia(constraints);
        streamRef.current = stream;

        if (videoRef.current) {
          videoRef.current.setAttribute("playsinline", "true");
          videoRef.current.muted = true;
          videoRef.current.srcObject = stream;
          await videoRef.current.play();
        }
      } catch (e) {
        console.error(e);
        await stopScan();
        setError("Kon camera niet starten. Check camera-toegang in Safari/Instellingen.");
        return;
      }

      setScanning(true);

      // Timeout -> manual entry
      if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
      scanTimerRef.current = setTimeout(async () => {
        await stopScan();
        setBarcodeFormat("MANUAL_ENTRY");
        setStep("details");
      }, SCAN_TIMEOUT_MS);

      // Try ZXing first (when available)
      if (libs.hasZXing) {
        try {
          codeReaderRef.current = new window.ZXingBrowser.BrowserMultiFormatReader();
          // decodeFromVideoElement is usually fine; if it throws on iOS, we fallback to Quagga.
          codeReaderRef.current.decodeFromVideoElement(videoRef.current, (result, err) => {
            if (result) {
              const text = result.getText ? result.getText() : (result.text || "");
              const fmt = result.getBarcodeFormat ? String(result.getBarcodeFormat()) : "UNKNOWN";

              if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
              scanTimerRef.current = null;

              setBarcodeValue(text || "");
              setBarcodeFormat(fmt || "UNKNOWN");

              stopScan().then(() => setStep("details"));
            }
          });
          return; // ZXing running
        } catch (e) {
          console.warn("ZXing failed, falling back to Quagga:", e);
          // continue to Quagga fallback if available
        }
      }

      // Quagga fallback (often better for 1D barcodes on iOS)
      if (libs.hasQuagga) {
        try {
          setUsingQuagga(true);

          // Quagga wants an element to draw into
          const target = quaggaTargetRef.current;
          if (!target) {
            setError("Quagga target ontbreekt. Herlaad de pagina.");
            return;
          }

          // Important for iOS: set numOfWorkers=0
          // Stop our own stream before Quagga starts its own (iOS can be picky)
          try {
            if (videoRef.current) { videoRef.current.pause(); videoRef.current.srcObject = null; }
          } catch {}
          if (streamRef.current) {
            try { streamRef.current.getTracks().forEach(t => t.stop()); } catch {}
            streamRef.current = null;
          }

          window.Quagga.init({
            inputStream: {
              type: "LiveStream",
              target,
              constraints: {
                facingMode: "environment"
              },
              area: { // focus area, relative
                top: "25%",
                right: "10%",
                left: "10%",
                bottom: "25%"
              }
            },
            locate: true,
            numOfWorkers: 0,
            decoder: {
              readers: [
                "ean_reader",
                "ean_8_reader",
                "upc_reader",
                "upc_e_reader",
                "code_128_reader",
                "code_39_reader",
                "code_93_reader",
                "i2of5_reader"
              ]
            }
          }, (err) => {
            if (err) {
              console.error(err);
              setError("Quagga kon niet starten. Gebruik handmatig of barcodefoto.");
              return;
            }
            window.Quagga.start();
          });

          window.Quagga.offDetected && window.Quagga.offDetected();
          window.Quagga.onDetected((data) => {
            const code = data?.codeResult?.code;
            const format = data?.codeResult?.format || "UNKNOWN";
            if (!code) return;

            if (scanTimerRef.current) clearTimeout(scanTimerRef.current);
            scanTimerRef.current = null;

            setBarcodeValue(code);
            setBarcodeFormat(String(format));

            // Stop Quagga and proceed
            try { window.Quagga.stop(); } catch {}
            stopScan().then(() => setStep("details"));
          });

          return;
        } catch (e) {
          console.error(e);
          await stopScan();
          setError("Scanner kon niet starten. Gebruik handmatig of barcodefoto.");
          return;
        }
      }

      // If we reach here, nothing worked.
      await stopScan();
      setError("Scanner startte niet. Gebruik handmatig of barcodefoto.");
    }

    function openManual() {
      setError(null);
      setBarcodeFormat("MANUAL_ENTRY");
      setStep("details");
    }

    async function handleSave() {
      setError(null);
      if (!storeName.trim()) { setError("Vul een winkelnaam in."); return; }
      if (!barcodeValue.trim() && !barcodeImageId) { setError("Vul een barcode-nummer in √≥f voeg een barcodefoto toe."); return; }

      const card = {
        id: Date.now().toString(),
        storeName: storeName.trim(),
        barcodeValue: barcodeValue.trim(),
        barcodeFormat: barcodeFormat || "MANUAL_ENTRY",
        cardImageId: cardImageId || null,
        barcodeImageId: barcodeImageId || null,
        showTextOnTile: !!showTextOnTile,
        dateAdded: new Date().toISOString(),
        usageCount: 0,
        lastUsed: null
      };

      onSaved(card);

      setStoreName("");
      setBarcodeValue("");
      setBarcodeFormat("");
      setCardImageId(null);
      setBarcodeImageId(null);
      setShowTextOnTile(true);
      setStep("scan");
    }

    async function onCropDone({ purpose, blob }) {
      const id = await idbPutImage(blob);
      if (purpose === "card") setCardImageId(id);
      if (purpose === "barcode") setBarcodeImageId(id);
      setCropRequest(null);
    }

    return (
      <div>
        <h2 className="section-title">Nieuw pasje</h2>
        <p className="section-text">
          Scan de barcode. Lukt het niet, dan ga je na enkele seconden automatisch naar handmatige invoer.
          Je kunt ook een kaartfoto en/of barcodefoto toevoegen.
        </p>

        {step === "scan" && (
          <div className="scan-box">
            <div className="field-label">Barcode scannen (camera)</div>

            <div className="scan-view-container">
              <video ref={videoRef} className="scan-video" playsInline muted style={{ display: usingQuagga ? "none" : "block" }}></video>
              <div ref={quaggaTargetRef} style={{ position: "absolute", inset: 0, display: usingQuagga ? "block" : "none" }}></div>
              {scanning && (
                <div className="scan-guides">
                  <div className="scan-guides-box"></div>
                  <div className="scan-guides-text">Plaats de barcode in het vak ‚Äî houd stil</div>
                </div>
              )}
            </div>

            <div className="button-row">
              {!scanning ? (
                <button className="button-secondary" onClick={startScan}>üì∑ Start scannen</button>
              ) : (
                <button className="button-secondary" onClick={stopScan}>‚úã Stop</button>
              )}
              <button className="button-secondary" onClick={openManual}>‚úçÔ∏è Handmatig</button>
            </div>

            {error && <div className="error-box">{error}</div>}
          </div>
        )}

        {step === "details" && (
          <div className="fullscreen-overlay">
            <div className="fullscreen-inner">
              <div className="fullscreen-card">
                <div style={{ fontSize: 18, fontWeight: 800, marginBottom: 6 }}>
                  {barcodeValue ? "Scannen gelukt!" : "Handmatig toevoegen"}
                </div>

                <div className="success-box" style={{ textAlign: "left" }}>
                  {barcodeValue ? (
                    <div>
                      Gelezen code: <strong>{barcodeValue}</strong>
                      <div style={{ fontSize: 11, marginTop: 4, color: "#22543d" }}>Je kunt de code hieronder nog aanpassen.</div>
                    </div>
                  ) : (
                    <div>Vul de gegevens in. Je kunt √≥√≥k een barcodefoto opslaan als fallback.</div>
                  )}
                </div>

                <div style={{ marginBottom: 12, textAlign: "left" }}>
                  <div className="field-label">Barcode-nummer (optioneel als je barcodefoto toevoegt)</div>
                  <input className="input" value={barcodeValue} onChange={e => setBarcodeValue(e.target.value)} placeholder="Bijv. 2620630013850" />
                  <div className="helper">Tip: als je geen cijfers hebt, voeg dan een barcodefoto toe.</div>
                </div>

                <div style={{ marginBottom: 12, textAlign: "left" }}>
                  <div className="field-label">Naam van de winkel</div>
                  <input className="input" value={storeName} onChange={e => setStoreName(e.target.value)} placeholder="Bijv. Albert Heijn, HEMA, Etos‚Ä¶" />
                </div>

                <div style={{ textAlign: "left" }}>
                  <div className="field-label">Afbeeldingen (optioneel)</div>
                  <div className="button-row">
                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üñºÔ∏è Kaartfoto toevoegen
                      <input type="file" accept="image/*" style={{ display: "none" }} onChange={(e) => {
                        const f = e.target.files?.[0]; if (!f) return;
                        setCropRequest({ file: f, aspect: 1, purpose: "card", title: "Kaartfoto uitsnijden (vierkant)" });
                        e.target.value = "";
                      }} />
                    </label>

                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üì∏ Barcodefoto toevoegen
                      <input type="file" accept="image/*" style={{ display: "none" }} onChange={(e) => {
                        const f = e.target.files?.[0]; if (!f) return;
                        setCropRequest({ file: f, aspect: 4, purpose: "barcode", title: "Barcode uitsnijden (breed)" });
                        e.target.value = "";
                      }} />
                    </label>
                  </div>

                  <div className="toggle-row">
                    <label>Toon tekst op tegel</label>
                    <input type="checkbox" checked={showTextOnTile} onChange={(e) => setShowTextOnTile(e.target.checked)} />
                  </div>
                  <div className="helper">Als je kaartfoto goed is, kun je tekst op de tegel uitzetten voor een rustiger scherm.</div>
                </div>

                {error && <div className="error-box">{error}</div>}

                <div className="button-row" style={{ justifyContent: "flex-end" }}>
                  <button className="button-secondary" onClick={() => setStep("scan")}>Annuleer</button>
                  <button className="button-primary" onClick={handleSave}>‚úÖ Opslaan</button>
                </div>
              </div>

              <div style={{ marginTop: 10, fontSize: 11, color: "#e2e8f0" }}>
                Na opslaan vind je het pasje onder <strong>Pasjes</strong>.
              </div>
            </div>

            {cropRequest && (
              <CropperModal request={cropRequest} onCancel={() => setCropRequest(null)} onDone={onCropDone} />
            )}
          </div>
        )}
      </div>
    );
  }

  function CropperModal({ request, onCancel, onDone }) {
    const { file, aspect, purpose, title } = request;

    const [imgUrl, setImgUrl] = useState(null);
    const imgRef = useRef(null);
    const stageRef = useRef(null);

    // transform state
    const [scale, setScale] = useState(1);
    const [pos, setPos] = useState({ x: 0, y: 0 });

    // pointer gesture
    const pointers = useRef(new Map());
    const lastPinch = useRef(null);

    const holeDims = useMemo(() => ({ wPct: 0.82, aspect }), [aspect]);

    useEffect(() => {
      const url = URL.createObjectURL(file);
      setImgUrl(url);
      return () => URL.revokeObjectURL(url);
    }, [file]);

    useEffect(() => {
      // reset on new image
      setScale(1);
      setPos({ x: 0, y: 0 });
      pointers.current.clear();
      lastPinch.current = null;
    }, [imgUrl]);

    function onPointerDown(e) {
      e.preventDefault();
      e.currentTarget.setPointerCapture?.(e.pointerId);
      pointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY });
      lastPinch.current = null;
    }
    function onPointerMove(e) {
      if (!pointers.current.has(e.pointerId)) return;
      const prev = pointers.current.get(e.pointerId);
      pointers.current.set(e.pointerId, { x: e.clientX, y: e.clientY });

      const pts = Array.from(pointers.current.values());
      if (pts.length === 1) {
        const dx = e.clientX - prev.x;
        const dy = e.clientY - prev.y;
        setPos(p => ({ x: p.x + dx, y: p.y + dy }));
      } else if (pts.length >= 2) {
        const [a, b] = pts;
        const dist = Math.hypot(a.x - b.x, a.y - b.y);
        if (!lastPinch.current) { lastPinch.current = { dist }; return; }
        const ratio = dist / (lastPinch.current.dist || dist);
        setScale(s => clamp(s * ratio, 0.05, 8)); // allow further zoom-out
        lastPinch.current = { dist };
      }
    }
    function onPointerUp(e) {
      pointers.current.delete(e.pointerId);
      if (pointers.current.size < 2) lastPinch.current = null;
    }
    function onWheel(e) {
      e.preventDefault();
      const factor = e.deltaY < 0 ? 1.06 : 0.94;
      setScale(s => clamp(s * factor, 0.05, 8));
    }

    function resetFit() {
      setScale(1);
      setPos({ x: 0, y: 0 });
    }

    async function exportCrop() {
      const imgEl = imgRef.current;
      const stageEl = stageRef.current;
      if (!imgEl || !stageEl) return;

      const stageRect = stageEl.getBoundingClientRect();

      // Hole in stage pixels
      const holeW = stageRect.width * holeDims.wPct;
      const holeH = holeW / aspect;
      const holeX = (stageRect.width - holeW) / 2;
      const holeY = (stageRect.height - holeH) / 2;

      // Output size
      const outW = purpose === "barcode" ? 1024 : 768;
      const outH = Math.round(outW / aspect);

      const canvas = document.createElement("canvas");
      canvas.width = outW;
      canvas.height = outH;
      const ctx = canvas.getContext("2d");

      const naturalW = imgEl.naturalWidth;
      const naturalH = imgEl.naturalHeight;

      // CHANGE: start from "contain" (min), so you can zoom OUT enough to include full image
      const baseScale = Math.min(stageRect.width / naturalW, stageRect.height / naturalH);
      const renderScale = baseScale * scale;
      const renderW = naturalW * renderScale;
      const renderH = naturalH * renderScale;

      const centerX = stageRect.width / 2 + pos.x;
      const centerY = stageRect.height / 2 + pos.y;

      const imgLeft = centerX - renderW / 2;
      const imgTop = centerY - renderH / 2;

      // Map hole back to source image coords
      const sx = (holeX - imgLeft) / renderScale;
      const sy = (holeY - imgTop) / renderScale;
      const sWidth = holeW / renderScale;
      const sHeight = holeH / renderScale;

      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0, 0, outW, outH);

      ctx.drawImage(imgEl, sx, sy, sWidth, sHeight, 0, 0, outW, outH);

      const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/jpeg", 0.9));
      if (!blob) return;
      onDone({ purpose, blob });
    }

    return (
      <div className="fullscreen-overlay" style={{ zIndex: 60 }}>
        <div className="fullscreen-inner">
          <div className="fullscreen-card">
            <div style={{ fontSize: 16, fontWeight: 800, marginBottom: 10 }}>{title}</div>

            <div
              ref={stageRef}
              className="crop-stage"
              onPointerDown={onPointerDown}
              onPointerMove={onPointerMove}
              onPointerUp={onPointerUp}
              onPointerCancel={onPointerUp}
              onWheel={onWheel}
            >
              {imgUrl && (
                <img
                  ref={imgRef}
                  src={imgUrl}
                  alt="crop"
                  style={{ transform: `translate(-50%, -50%) translate(${pos.x}px, ${pos.y}px) scale(${scale})` }}
                  draggable={false}
                />
              )}

              <div className="crop-mask">
                <div
                  className="crop-hole"
                  style={{
                    width: `${holeDims.wPct * 100}%`,
                    height: `${(holeDims.wPct / aspect) * 100}%`
                  }}
                ></div>
              </div>
            </div>

            <div className="crop-controls">
              <button className="button-secondary" onClick={() => setScale(s => clamp(s * 0.85, 0.05, 8))}>‚ûñ Zoom uit</button>
              <button className="button-secondary" onClick={resetFit}>‚Ü∫ Reset</button>
              <button className="button-secondary" onClick={() => setScale(s => clamp(s * 1.18, 0.05, 8))}>‚ûï Zoom in</button>
            </div>

            <div className="helper" style={{ marginTop: 10 }}>
              Sleep om te positioneren. Pinch/zoom om in/uit te zoomen. (Je kunt nu verder uitzoomen dan eerder.)
            </div>

            <div className="button-row" style={{ justifyContent: "flex-end" }}>
              <button className="button-secondary" onClick={onCancel}>Annuleer</button>
              <button className="button-primary" onClick={exportCrop}>‚úÖ Gebruik uitsnede</button>
            </div>
          </div>
        </div>
      </div>
    );
  }

  function CardsTab({ cards, sortBy, onOpenCard }) {
    const [search, setSearch] = useState("");
    const filtered = cards.filter(c => (c.storeName || "").toLowerCase().includes(search.toLowerCase()));

    return (
      <div>
        <h2 className="section-title">Mijn pasjes</h2>
        <p className="section-text">Tik op een pasje om te openen.</p>

        <div style={{ marginBottom: 12 }}>
          <input className="input" placeholder="Zoek op winkelnaam..." value={search} onChange={e => setSearch(e.target.value)} />
        </div>

        {filtered.length === 0 ? (
          <div className="empty-state"><div className="empty-icon">üí≥</div><div>Nog geen pasjes. Voeg er √©√©n toe via <strong>Scan</strong>.</div></div>
        ) : (
          <div className="card-grid">
            {filtered.map(card => <CardTile key={card.id} card={card} sortBy={sortBy} onClick={() => onOpenCard(card)} />)}
          </div>
        )}
      </div>
    );
  }

  function CardTile({ card, sortBy, onClick }) {
    const [imgUrl, setImgUrl] = useState(null);

    useEffect(() => {
      let url = null;
      let cancelled = false;
      (async () => {
        if (card.cardImageId) {
          const blob = await idbGetImage(card.cardImageId);
          if (cancelled) return;
          url = blobToObjectUrl(blob);
          setImgUrl(url);
        } else {
          setImgUrl(null);
        }
      })();
      return () => { cancelled = true; if (url) URL.revokeObjectURL(url); };
    }, [card.cardImageId]);

    const showText = card.showTextOnTile !== false;

    return (
      <div className="card-item" onClick={onClick}>
        {imgUrl ? (
          <>
            <img className="card-image" src={imgUrl} alt={card.storeName || "kaart"} />
            {showText && (
              <div className="card-overlay">
                <div className="card-title">{card.storeName}</div>
                <div className="card-sub">Tik om te openen</div>
                {sortBy === "mostUsed" && (
                  <div className="card-sub" style={{ marginTop: 4 }}>
                    {(card.usageCount || 0) ? `${card.usageCount}√ó gebruikt` : "Nog niet gebruikt"}
                  </div>
                )}
              </div>
            )}
          </>
        ) : (
          <div className="card-plain-center">
            <div style={{ fontSize: 28 }}>üí≥</div>
            {showText ? (
              <>
                <div className="card-title" style={{ color: "#1a202c" }}>{card.storeName}</div>
                <div className="card-sub">Tik om te openen</div>
              </>
            ) : (
              <div className="card-sub" style={{ color: "#4a5568" }}>Tik om te openen</div>
            )}
          </div>
        )}
      </div>
    );
  }

  function SettingsTab({ cards, sortBy, setSortBy, onDeleteCard, onEditCard }) {
    const [editingCard, setEditingCard] = useState(null);
    const [editName, setEditName] = useState("");
    const [editCode, setEditCode] = useState("");
    const [editShowText, setEditShowText] = useState(true);
    const [cropRequest, setCropRequest] = useState(null); // for adding/updating images in edit modal

    function openEdit(card) {
      setEditingCard(card);
      setEditName(card.storeName || "");
      setEditCode(card.barcodeValue || "");
      setEditShowText(card.showTextOnTile !== false);
    }
    function saveEdit() {
      if (!editingCard) return;
      onEditCard(editingCard.id, { storeName: editName.trim() || editingCard.storeName, barcodeValue: editCode.trim(), showTextOnTile: !!editShowText });
      setEditingCard(null);
    }

    async function replaceImage(purpose, blob) {
      if (!editingCard) return;
      const newId = await idbPutImage(blob);
      const oldId = purpose === "card" ? editingCard.cardImageId : editingCard.barcodeImageId;
      if (oldId) { try { await idbDeleteImage(oldId); } catch {} }
      const updates = purpose === "card" ? { cardImageId: newId } : { barcodeImageId: newId };
      onEditCard(editingCard.id, updates);
      setEditingCard(prev => prev ? { ...prev, ...updates } : prev);
    }

    async function removeImage(purpose) {
      if (!editingCard) return;
      const oldId = purpose === "card" ? editingCard.cardImageId : editingCard.barcodeImageId;
      if (oldId) { try { await idbDeleteImage(oldId); } catch {} }
      const updates = purpose === "card" ? { cardImageId: null } : { barcodeImageId: null };
      onEditCard(editingCard.id, updates);
      setEditingCard(prev => prev ? { ...prev, ...updates } : prev);
    }

    async function onCropDone({ purpose, blob }) {
      await replaceImage(purpose, blob);
      setCropRequest(null);
    }

    function exportData() {
      const data = { cards, sortBy, exportedAt: new Date().toISOString() };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "pashie-backup.json";
      a.click();
      URL.revokeObjectURL(url);
    }

    function importData(ev) {
      const file = ev.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = e => {
        try {
          const data = JSON.parse(e.target.result);
          if (!data.cards || !Array.isArray(data.cards)) { alert("Ongeldig bestand."); return; }
          saveStorage("pashie_cards", data.cards);
          saveStorage("pashie_sort", data.sortBy || "alphabetical");
          location.reload();
        } catch { alert("Kon het bestand niet lezen."); }
      };
      reader.readAsText(file);
    }

    return (
      <div>
        <h2 className="section-title">Instellingen</h2>
        <p className="section-text">Sortering, back-up, en pasjesbeheer.</p>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Sortering</div>
          <div className="button-row">
            <button className="button-secondary" onClick={() => setSortBy("alphabetical")} style={{ background: sortBy==="alphabetical" ? "#e6fffa" : "#edf2f7" }}>A ‚Üí Z</button>
            <button className="button-secondary" onClick={() => setSortBy("date")} style={{ background: sortBy==="date" ? "#e6fffa" : "#edf2f7" }}>Nieuwste</button>
            <button className="button-secondary" onClick={() => setSortBy("mostUsed")} style={{ background: sortBy==="mostUsed" ? "#e6fffa" : "#edf2f7" }}>Meest gebruikt</button>
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Back-up & herstel</div>
          <div className="button-row">
            <button className="button-secondary" onClick={exportData}>üíæ Exporteer</button>
            <label className="button-secondary" style={{ cursor: "pointer" }}>
              üìÇ Importeer
              <input type="file" accept="application/json" style={{ display: "none" }} onChange={importData} />
            </label>
          </div>
          <div className="helper">Let op: foto‚Äôs zitten in IndexedDB en gaan niet mee in de JSON-export (kan later als we willen).</div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Pasjes beheren</div>
          {cards.length === 0 ? (
            <div className="helper">Nog geen pasjes opgeslagen.</div>
          ) : (
            <div style={{ maxHeight: 320, overflowY: "auto" }}>
              {cards.slice().sort((a,b) => (a.storeName||"").localeCompare(b.storeName||"")).map(card => (
                <div key={card.id} style={{ display: "flex", alignItems: "center", justifyContent: "space-between", padding: "8px 0", borderBottom: "1px solid #e2e8f0", fontSize: 13 }}>
                  <div style={{ fontWeight: 800 }}>{card.storeName}</div>
                  <div style={{ display: "flex", gap: 8 }}>
                    <button className="button-secondary" style={{ padding: "8px 12px", fontSize: 12 }} onClick={() => openEdit(card)}>‚úèÔ∏è Bewerken</button>
                    <button className="button-danger" style={{ padding: "8px 12px", fontSize: 12 }} onClick={() => { if (confirm(`Pasje voor "${card.storeName}" verwijderen? (ook foto‚Äôs worden verwijderd)`)) onDeleteCard(card.id); }}>Verwijder</button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>

        {editingCard && (
          <div className="fullscreen-overlay">
            <div className="fullscreen-inner">
              <div className="fullscreen-card">
                <div style={{ fontSize: 16, fontWeight: 800, marginBottom: 10 }}>Pasje bewerken</div>

                <div style={{ marginBottom: 12, textAlign: "left" }}>
                  <div className="field-label">Winkelnaam</div>
                  <input className="input" value={editName} onChange={e => setEditName(e.target.value)} />
                </div>

                <div style={{ marginBottom: 12, textAlign: "left" }}>
                  <div className="field-label">Barcode-nummer</div>
                  <input className="input" value={editCode} onChange={e => setEditCode(e.target.value)} />
                </div>


                <div style={{ textAlign: "left", marginBottom: 12 }}>
                  <div className="field-label">Foto‚Äôs</div>
                  <div className="button-row" style={{ marginTop: 8 }}>
                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üñºÔ∏è {editingCard.cardImageId ? "Kaartfoto wijzigen" : "Kaartfoto toevoegen"}
                      <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        onChange={(e) => {
                          const f = e.target.files?.[0];
                          if (!f) return;
                          setCropRequest({ file: f, aspect: 1, purpose: "card", title: "Kaartfoto uitsnijden (vierkant)" });
                          e.target.value = "";
                        }}
                      />
                    </label>

                    <label className="button-secondary" style={{ cursor: "pointer" }}>
                      üì∏ {editingCard.barcodeImageId ? "Barcodefoto wijzigen" : "Barcodefoto toevoegen"}
                      <input
                        type="file"
                        accept="image/*"
                        style={{ display: "none" }}
                        onChange={(e) => {
                          const f = e.target.files?.[0];
                          if (!f) return;
                          setCropRequest({ file: f, aspect: 4, purpose: "barcode", title: "Barcode uitsnijden (breed)" });
                          e.target.value = "";
                        }}
                      />
                    </label>

                    {editingCard.cardImageId && (
                      <button className="button-danger" style={{ padding: "10px 14px" }} onClick={() => removeImage("card")}>
                        Verwijder kaartfoto
                      </button>
                    )}
                    {editingCard.barcodeImageId && (
                      <button className="button-danger" style={{ padding: "10px 14px" }} onClick={() => removeImage("barcode")}>
                        Verwijder barcodefoto
                      </button>
                    )}
                  </div>

                  <div className="helper">
                    Je kunt hier achteraf je kaartfoto en barcodefoto toevoegen of wijzigen.
                  </div>
                </div>

                <div className="toggle-row" style={{ marginTop: 0 }}>
                  <label>Toon tekst op tegel</label>
                  <input type="checkbox" checked={editShowText} onChange={(e) => setEditShowText(e.target.checked)} />
                </div>

                <div className="button-row" style={{ justifyContent: "flex-end" }}>
                  <button className="button-secondary" onClick={() => setEditingCard(null)}>Annuleer</button>
                  <button className="button-primary" onClick={saveEdit}>üíæ Opslaan</button>
                </div>

                <div className="helper">
                  Handleiding is bijgewerkt. (Volgende stap kan zijn: ook kaartfoto/barcodefoto kunnen wijzigen bij ‚ÄúBewerken‚Äù.)
                </div>
              </div>
            </div>

            {cropRequest && (
              <CropperModal
                request={cropRequest}
                onCancel={() => setCropRequest(null)}
                onDone={onCropDone}
              />
            )}
          </div>
        )}
      </div>
    );
  }function HelpTab() {
    return (
      <div>
        <h2 className="section-title">Handleiding</h2>
        <p className="section-text">Scannen, toevoegen, foto‚Äôs en installeren als PWA.</p>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Pasje toevoegen</div>
          <div className="helper">
            Ga naar <strong>Scan</strong> ‚Üí <strong>Start scannen</strong>. Plaats de barcode in het witte vak.
            Als er binnen enkele seconden niets wordt gevonden, ga je automatisch door naar handmatige invoer.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Kaartfoto toevoegen (eigen afbeelding)</div>
          <div className="helper">
            In het ‚ÄúOpslaan‚Äù-scherm kun je een <strong>kaartfoto</strong> uploaden en uitsnijden (vierkant). Je kunt verder uitzoomen om meer van de foto te pakken.
            Zet eventueel <strong>Toon tekst op tegel</strong> uit als de foto genoeg herkenning geeft.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Barcodefoto (fallback)</div>
          <div className="helper">
            Heeft jouw kaart geen leesbare cijferreeks? Voeg dan een <strong>barcodefoto</strong> toe. Bij openen van het pasje tonen we die fullscreen als fallback.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Pasje gebruiken</div>
          <div className="helper">
            Ga naar <strong>Pasjes</strong>, tik op een pasje. Je krijgt de barcode fullscreen. Tip: zet je schermhelderheid hoog bij de kassa.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">PWA installeren</div>
          <div className="helper">
            <strong>iPhone (Safari):</strong> Deel-knop ‚Üí ‚ÄúZet op beginscherm‚Äù.<br/>
            <strong>Android (Chrome):</strong> menu (‚ãÆ) ‚Üí ‚ÄúInstalleren‚Äù / ‚ÄúToevoegen aan startscherm‚Äù.
          </div>
        </div>

        <div className="scan-box" style={{ borderStyle: "solid" }}>
          <div className="field-label">Back-up</div>
          <div className="helper">
            Export/Import bewaart de pasjeslijst. Foto‚Äôs staan in <strong>IndexedDB</strong> en gaan nog niet mee in JSON-export.
            (Dat kunnen we later toevoegen.)
          </div>
        </div>
      </div>
    );
  }

  function BarcodeOverlay({ card, onClose }) {
    const svgRef = useRef(null);
    const [barcodeImgUrl, setBarcodeImgUrl] = useState(null);

    useEffect(() => {
      let url = null;
      let cancelled = false;
      (async () => {
        if (card.barcodeImageId) {
          const blob = await idbGetImage(card.barcodeImageId);
          if (cancelled) return;
          url = blobToObjectUrl(blob);
          setBarcodeImgUrl(url);
        } else {
          setBarcodeImgUrl(null);
        }
      })();
      return () => { cancelled = true; if (url) URL.revokeObjectURL(url); };
    }, [card.barcodeImageId]);

    useEffect(() => {
      const el = svgRef.current;
      if (!el) return;
      while (el.firstChild) el.removeChild(el.firstChild);
      if (!card.barcodeValue) return;

      if (typeof JsBarcode === "function") {
        try {
          JsBarcode(el, card.barcodeValue, { format: "CODE128", width: 2, height: 100, displayValue: true, margin: 10, fontSize: 18 });
        } catch (e) { console.error(e); }
      }
    }, [card.barcodeValue]);

    const showGenerated = !!card.barcodeValue;

    return (
      <div className="fullscreen-overlay">
        <div className="fullscreen-inner">
          <div className="fullscreen-close-row">
            <button className="button-secondary" onClick={onClose}>‚¨ÖÔ∏é Terug</button>
            <div className="chip">üîç Kassascanner</div>
          </div>

          <div className="fullscreen-card">
            <div style={{ fontSize: 18, fontWeight: 800, marginBottom: 6 }}>{card.storeName}</div>

            {showGenerated ? (
              <>
                <svg ref={svgRef} className="barcode-svg" preserveAspectRatio="xMidYMid meet"></svg>
                <div className="barcode-value">{card.barcodeValue}</div>
              </>
            ) : barcodeImgUrl ? (
              <>
                <div style={{ fontSize: 12, color: "#4a5568", marginBottom: 8 }}>Barcodefoto (fallback)</div>
                <img src={barcodeImgUrl} alt="barcode foto" style={{ width: "100%", height: "160px", objectFit: "contain", background: "#fff", borderRadius: "12px", border: "1px solid #e2e8f0", padding: "8px" }} />
                <div className="helper" style={{ marginTop: 8 }}>Tip: zet je schermhelderheid hoog voor betere leesbaarheid.</div>
              </>
            ) : (
              <div className="error-box">Geen barcode-nummer en geen barcodefoto opgeslagen.</div>
            )}
          </div>

          <div style={{ marginTop: 10, fontSize: 11, color: "#e2e8f0" }}>Tip: houd je telefoon stabiel onder de scanner.</div>
        </div>
      </div>
    );
  }

  ReactDOM.render(<App />, document.getElementById("root"));
</script>
</body>
</html>
